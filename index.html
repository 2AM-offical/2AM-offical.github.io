<!DOCTYPE html>





<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="they said the fruit never gon&apos; fall far from the tree">
<meta property="og:type" content="website">
<meta property="og:title" content="Room of Requirment">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Room of Requirment">
<meta property="og:description" content="they said the fruit never gon&apos; fall far from the tree">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Room of Requirment">
<meta name="twitter:description" content="they said the fruit never gon&apos; fall far from the tree">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Room of Requirment</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Room of Requirment</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Less is More</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-home">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/CSE201W4-QueryEvaluation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/24/CSE201W4-QueryEvaluation/" class="post-title-link" itemprop="url">CSE201W4_QueryEvaluation</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-24 13:39:24" itemprop="dateCreated datePublished" datetime="2019-09-24T13:39:24+08:00">2019-09-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-10-02 16:28:28" itemprop="dateModified" datetime="2019-10-02T16:28:28+08:00">2019-10-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id><a href="#" class="headerlink" title=" "></a> </h1><h1 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>查询处理的基本步骤：</p>
<ol>
<li>语法分析与翻译<br>查询处理中系统首先必须把查询语句翻译成系统的内部表示形式。该翻译过程类似于编译器的语法分析器所做的工作。在此过程中，语法分析器检查用户查询的语法，验证查询中出现的关系名是数据库中的关系名等。<br>系统构造该查询语句的语法分析树表示，然后将之翻译成关系代数表达式。</li>
<li>优化<br><strong>查询执行引擎（query-execution engine）</strong>接受一个<strong>查询执行计划（query-execution engine）</strong>，执行该计划并把结果返回给查询。<br>给定查询的不同执行计划会有不同的代价。我们不能寄希望于用户写出具有最高效率执行计划的查询语句。相反，构造具有最小查询执行代价的查询执行计划应当是系统的责任。这项工作叫作<em>查询优化</em>。</li>
<li>执行</li>
</ol>
<h2 id="查询代价的度量"><a href="#查询代价的度量" class="headerlink" title="查询代价的度量"></a>查询代价的度量</h2><p>查询处理的代价可以通过该查询对各种资源的使用情况进行度量，这些资源包括<strong>磁盘存取、执行一个查询所用CPU时间，还有在并行/分布式数据库系统中的通信代价</strong><br><em>在大型数据库系统中，在磁盘上存取数据的代价通常是最主要的代价，因为磁盘存取比内存操作速度慢。此外，CPU速度的提升比磁盘速度的提升要快的多，这样很可能花费在磁盘存取上的时间仍将决定整个查询的时间。</em><br>我们用<strong>传送磁盘块数</strong>以及<strong>搜索磁盘次数</strong>来度量查询计算计划的代价：<br>假设磁盘子系统传输一个块的数据平均消耗$t_T$秒，<br>磁盘块平均访问时间（磁盘搜索时间加上旋转延迟）为$t_S$秒，<br>则一次传输$b$个块以及执行$S$次磁盘搜索的操作将消耗<script type="math/tex">b * t_T + S * t_S</script>秒<br>$t_T$和$t_S$的值必须针对所使用的磁盘系统进行计算，而如今高端磁盘的典型数值通常是$t_S = 4$毫秒和$t_T = 0.1$毫秒。</p>
<h2 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h2><h3 id="使用文件扫描和索引的选择"><a href="#使用文件扫描和索引的选择" class="headerlink" title="使用文件扫描和索引的选择"></a>使用文件扫描和索引的选择</h3><ul>
<li><strong>文件扫描（file scan）</strong>：<br>在查询处理中，<strong>文件扫描</strong>是存取数据最低级的操作。文件扫描是用于定位、检索满足选择条件的记录的搜索算法。在关系系统中，若关系保存在单个专用的文件中，采用文件扫描就可以读取整个关系。<br><em>线性搜索和二分搜索属于文件扫描</em></li>
<li><strong>索引扫描（index scan）</strong>：<br>使用索引的搜索算法称为<strong>索引扫描</strong>。我们用选择谓词来指导我们在查询处理中使用哪个索引。</li>
</ul>
<ol>
<li><strong>线性搜索（linear search）</strong>：<br>系统扫描每一个文件块，对所有记录都进行测试，看它们是否满足选择条件。<br>开销：<script type="math/tex">t_s + b_r * t_T</script> <em>一次初始搜索加上$b_r$个块运输，$b_r$表示在文件中的块数量</em><br>若使用码属性值比较，则平均开销：<script type="math/tex">t_s + (b_r/2) * t_T</script> 因为最多一条记录满足条件，所以只要找到所需的记录，扫描就可以终止。在最坏的情况下，仍需要$b_r$个块传输。<br>虽然线性搜索比其他实现操作的算法速度要慢，但它可用于任何文件，不用管该文件的顺序、索引的可用性，以及选择操作的种类。</li>
<li><strong>二分搜索（binary search）</strong>：<br>只有在等值比较且按序排列的情况下可以用<br>开销：<script type="math/tex">\lceil log_2(b_r) \rceil * (t_T + t_S)</script></li>
<li><strong>$B^+$树，主索引，码属性，等值比较</strong>：<br>开销：<script type="math/tex">(h_i + 1) * (t_T + t_S)</script><br>$h_i$表示索引的高度。索引查找穿越树的高度，再加上一次I/O来取记录；每个这样的I/O操作需要一次搜索和块传输</li>
<li><strong>$B^+$树，主索引，非码属性，等值比较</strong>：<br>开销：<script type="math/tex">h_i * (t_T + t_S) + t_S + t_T * b</script><br>树的每层一次搜索，第一个块一次搜索。$b$是包含具有指定搜索码记录的块数。</li>
<li><strong>$B^+$树，辅助索引，码属性，等值比较</strong>：<br>开销：<script type="math/tex">(h_i + 1) * (t_T + t_S)</script><br>这种情形和主索引相似</li>
<li><strong>$B^+$树，辅助索引，非码属性，等值比较</strong>：<br>开销：<script type="math/tex">(h_i + n) * (t_T + t_S)</script><br>$n$是记录数，索引查找的代价和4类似，但是每条记录可能在不同的块上，这需要每条记录一次搜索。如果$n$值比较大，代价可能会非常高。</li>
<li><strong>$B^+$树，主索引，比较</strong>：<br>开销：<script type="math/tex">h_i * (t_T + t_S) + t_S + b * t_T</script><br><em>和主索引，非码属性，等值比较情形一样</em><br>形如$A \geq v$，我们在索引中寻找值$v$，以检索出满足条件$A = v$的首条记录。从该元组开始到文件末尾进行一次文件扫描就返回所有满足该条件的元组。形如$A &gt; v$，文件扫描从第一条满足$A &gt; v$的记录开始。<br>若为$A &lt; v 或 A \leq v$的比较式，从文件头开始进行文件扫描，直到遇上首条满足$A = v 或 A &gt; v$的元组为止。</li>
<li><strong>$B^+$树，辅助索引，比较</strong>：<br>开销：<script type="math/tex">(h_i + n) * (t_T + t_S)</script><br><em>和辅助索引，非码属性，等值比较情形一样</em><br>对于$ \leq$情形，扫描最底层索引块是从最小值开始直到$v$为止<br>对于$ \geq$情形，扫描是从$v$开始直到最大值为止<br>辅助索引提供了指向记录的指针，但我们需要使用指针以取得实际的记录。由于连续的记录可能存在于不同的磁盘块中，因此每取一条记录可能需要一次I/O操作，即需要一次磁盘搜索和一次块传输。<br>如果检索得到的记录数很大的话，使用辅助索引的代价甚至比线性搜索还要大，因此辅助索引应该仅在选择得到的记录很少时使用。</li>
</ol>
<h3 id="复杂选择的实现"><a href="#复杂选择的实现" class="headerlink" title="复杂选择的实现"></a>复杂选择的实现</h3><h4 id="合取选择（Conjunctive-Selections"><a href="#合取选择（Conjunctive-Selections" class="headerlink" title="合取选择（Conjunctive Selections)"></a>合取选择（Conjunctive Selections)</h4><script type="math/tex; mode=display">
\sigma_{\theta_1 \bigwedge \theta_2 \bigwedge ... \bigwedge \theta_n} (r)</script><p>利用一个索引实现：</p>
<ol>
<li>从上述的选择运算中选出对于$\sigma_{\theta_i}(r)$开销最小的算法来查找$\theta_i$</li>
<li>在<strong>内存缓冲区</strong>中，我们通过测试每条检索到的记录是否满足其余的简单条件。</li>
</ol>
<p><em>在这个事件中，如何去选取第一个条件是十分重要的</em></p>
<p>使用组合索引的合取选择：<br>使用合适的<em>组合索引(composite index)</em>，即在多个属性上建立的一个索引来检索。</p>
<h4 id="析取选择（Disjunctive-Selections"><a href="#析取选择（Disjunctive-Selections" class="headerlink" title="析取选择（Disjunctive Selections)"></a>析取选择（Disjunctive Selections)</h4><script type="math/tex; mode=display">
\sigma_{\theta_1 \bigvee \theta_2 \bigvee ... \bigvee \theta_n}(r)</script><p>通过标识符的交：</p>
<ul>
<li>线性扫描</li>
<li>如果在析取选择中所有条件上均有相应的存取路径存在，则逐个扫描索引获取满足单个条件的元组指针。检索到的所有指针的并集就是指向满足析取条件的额所有元组的指针集。然后利用这些指针检索实际的记录</li>
</ul>
<h4 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h4><script type="math/tex; mode=display">
\sigma_{\neg \theta}(r)</script><ul>
<li>线性扫描</li>
<li>如果有相应的存取路径：<br>利用索引找到符合的记录，$\sigma_{\neg \theta}(r) 就是在$r$中对条件$\theta$取值为假的元组的集合</li>
</ul>
<h4 id="删除重复值"><a href="#删除重复值" class="headerlink" title="删除重复值"></a>删除重复值</h4><p>重复值的删除可以通过散列或分类来实现</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>数据排序在数据库系统中有重要的作用：</p>
<ol>
<li>SQL查询会指明对结果进行排序</li>
<li>当输入的关系已排序时，关系运算中的一些运算（如连接运算）能够得到高效实现。</li>
</ol>
<p>通过在排序码上建立索引，然后使用该索引按序读取关系，可以完成对关系的排序。然而，这一过程仅仅在逻辑上通过索引对关系排序，而没有在物理上排序。因此，顺序读取元组可能导致每读一个元组就要访问一次磁盘。</p>
<h3 id="外部排序归并算法"><a href="#外部排序归并算法" class="headerlink" title="外部排序归并算法"></a>外部排序归并算法</h3><p>对于内存中能够完全容纳关系的话，可以利用标准的排序技术（如快速排序）</p>
<p>对不能全部放在内存中的关系的排序称为<strong>外排序（external sorting）</strong>。外排序中最常用的技术是<strong>外部排序归并（external sort-merge)</strong>算法。</p>
<p>令$M$表示内存缓冲区中可以用于排序的块数，即内存的缓冲区能容纳的磁盘块数。</p>
<ol>
<li><p>建立多个排好序的<strong>归并段（run）</strong>。每个归并段都是排序过的，但仅包含关系中的部分记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = 0;</span><br><span class="line">repeat</span><br><span class="line">      读入关系的$M$块数据或剩下的不足$M$块数据；</span><br><span class="line">      在内存中对关系的这一部分进行排序；</span><br><span class="line">      将排好序的数据写到归并段文件$R_i$中；</span><br><span class="line">      $i = i + 1$</span><br><span class="line">until 到达关系末尾</span><br></pre></td></tr></table></figure>
</li>
<li><p>对归并段进行<em>归并</em>，暂时假定归并段的总数$N$小于$M$,这样我们可以为每个归并段文件分配一个块，此外剩下的空间还应能容纳存放结果的一个块。为$N$个归并段文件$R_i$各分配一个内存缓冲块，并分别读入一个数据块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">      在所有缓冲块中按序挑选第一个元组；</span><br><span class="line">      把该元组作为输出写出，并将其从缓冲块中删除；</span><br><span class="line">      if 任何一个归并段文件$R_i$的缓冲块为空并且没有到达$R_i$末尾</span><br><span class="line">           then 读入$R_i$的下一块到相应的缓冲块</span><br><span class="line">until 所有的缓冲块均为空</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果关系比内存大的多，则在第一阶段可能产生$M$个甚至更多的归并段，在这种情况下，归并操作需要分多躺进行。由于内存足以容纳$M - 1$个缓冲块，因此每趟归并可以用$M - 1$个归并段作为输入<br>最初的那趟归并过程：头$M - 1$个归并段如前第2⃣️点所述进行归并得到一个归并段作为下一趟的输入。接下来的$M - 1$个归并段类似的进行归并，如此下去，知道所有的初始归并段都处理过为止。此时，归并段的数目减少到原来的$1/(M - 1)$，如果归并后的归并段数目仍大于等于$M$，则以上一趟归并创建的归并段作为输入进行下一趟归并，直到归并段数目小于$M$</p>
</li>
</ol>
<h3 id="外部排序归并的代价分析"><a href="#外部排序归并的代价分析" class="headerlink" title="外部排序归并的代价分析"></a>外部排序归并的代价分析</h3><p>假定$b_r$表示关系$r$中记录的磁盘块数，$M$表示内存缓冲区中可以用于排序的块数，$b_b$表示缓冲块（每次读取$b_b$块从每个归并段。</p>
<ul>
<li>磁盘块传输的总数：<script type="math/tex; mode=display">
b_r(2\lceil log_{\lfloor M/b_b \rfloor - 1}(b_r/M)\rceil + 1)</script></li>
<li>磁盘搜索的总次数：<script type="math/tex; mode=display">
2\lceil b_r/M \rceil + \lceil b_r/b_b \rceil (2\lceil log_{\lfloor M/b_b \rfloor - 1}(b_r/M)\rceil - 1)</script></li>
</ul>
<h2 id="连接运算"><a href="#连接运算" class="headerlink" title="连接运算"></a>连接运算</h2><h3 id="嵌套循环连接-Nested-Loop-Join"><a href="#嵌套循环连接-Nested-Loop-Join" class="headerlink" title="嵌套循环连接(Nested-Loop Join)"></a>嵌套循环连接(Nested-Loop Join)</h3><p>最简单的连接算法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for each 元组 $t_r$ in r do begin</span><br><span class="line">         for each 元组 $t_s$ in s do begin</span><br><span class="line">                  测试元组对（t_r, t_s)是否满足连接条件\theta</span><br><span class="line">                  如果满足，把t_r t_s加到结果中</span><br><span class="line">         end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>关系$r$称为连接的<strong>外层关系（outer relation）</strong>，而$s$称为连接的<strong>内层关系（inner relation）</strong>。<br>与选择算法中使用的线性文件扫描算法类似，嵌套循环连接算法不要求有索引，并且不管连接条件是什么，该算法均可以使用。将其变为自然连接只需要删除$t_r <em> t_s$的重复属性。
</em>嵌套连接算法的代价很大，因为该算法逐个检查两个关系中的每一对元组。*</p>
<p>我们假设$n_r$和$n_s$分别表示$r$和$s$中的元组数，$b_r$和$b_s$分别代表包含关系$r$和$s$中元组的磁盘块数<br>在最坏的情况下，缓冲区只能容纳每个关系的一个数据块：</p>
<ul>
<li>共需$n_r * b_s + b_r$次块传输</li>
<li>共需$n_r + b_r$次磁盘搜索，*对每次扫描内层关系$s$我们只需一次磁盘搜索，读取关系$r$一共需要$b_r$次磁盘搜索</li>
</ul>
<p>在最好的情况下，内存有足够的空间同时容纳两个关系，此时每一数据块只需读一次</p>
<ul>
<li>$b_r + b_s$块传输</li>
<li>2次磁盘搜索</li>
</ul>
<p>如果只有一个关系能完全放在内存中，那么把内层关系作为这个关系来处理是有好处的。因为这样内层循环只需要读一次，如果把$s$小到可以装入内存，那么我们的策略只需$b_r + b_s$次块传输和两次磁盘搜索，<em>其代价与两个关系能同时装入内存的情形相同</em>。</p>
<h3 id="块嵌套循环连接（Block-Nested-Loop-Join"><a href="#块嵌套循环连接（Block-Nested-Loop-Join" class="headerlink" title="块嵌套循环连接（Block Nested-Loop Join)"></a>块嵌套循环连接（Block Nested-Loop Join)</h3><p>因缓冲区太小而内存不足以完全容纳任何一个关系时，如果我们以块的方式而不是以元组的方式处理关系，仍然可以减少不少块读写次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for each 块 B_r of r do begin</span><br><span class="line">    for each 块 B_s of s do begin</span><br><span class="line">       for each 元组 t_r in B_r do begin</span><br><span class="line">          for each 元组 t_s in B_s do begin</span><br><span class="line">              测试元组对(t_r, t_s)是否满足连接条件</span><br><span class="line">              如果满足，把t_r * t_s加到结果中</span><br><span class="line">          end</span><br><span class="line">       end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>在最坏的情况下：</p>
<ul>
<li>共需$b_r * b_s + b_r$次块传输</li>
<li>共需$2b_r$次磁盘搜索</li>
</ul>
<p>在最好的情况下，内存能够容纳内层关系:</p>
<ul>
<li>$b_r + b_s$次块传输</li>
<li>2次磁盘搜索</li>
</ul>
<p><em>进一步改进嵌套循环和块嵌套循环：通过对内层循环轮流做向前、向后的扫描。该扫描方法对磁盘块读写请求进行排序，使得上一次扫描时留在缓冲区的数据可以重用，从而减少磁盘存取次数</em></p>
<h3 id="索引嵌套循环连接（Indexed-Nested-Loop-Join"><a href="#索引嵌套循环连接（Indexed-Nested-Loop-Join" class="headerlink" title="索引嵌套循环连接（Indexed Nested Loop Join)"></a>索引嵌套循环连接（Indexed Nested Loop Join)</h3><p>在嵌套循环连接中，若在内层循环的连接属性上有索引，则可以用索引查找替代文件扫描。对于外层关系$r$的每一个元组$t_r$，可以利用索引查找$s$中和元组$t_r$满足连接的元组</p>
<p>最坏的情况下，缓冲区只能容纳关系$r$的一块和索引的一块。<br>这种状况下，连接的开销为：$b_r + n_r <em> c$次<em>*块传输和磁盘搜索</em></em><br>$c$是使用连接条件对关系$s$进行单次选择操作的代价</p>
<p>代价公式表明，如果两个关系$r, s$上均有索引时，一般把元组较少的关系做外层关系时效果更好</p>
<h3 id="归并连接-Merge-Join"><a href="#归并连接-Merge-Join" class="headerlink" title="归并连接(Merge Join)"></a>归并连接(Merge Join)</h3><p><strong>归并连接算法</strong>（又称<strong>排序—归并—连接（sort-merge join)</strong>算法）可用于计算自然连接和等值连接</p>
<p>假设所有集合$S_s$都能被装进内存，这时的开销是：</p>
<ul>
<li>$b_r + b_s$次磁盘块传输</li>
<li><script type="math/tex">\lceil b_r/b_b \rceil + \lceil b_s/b_b \rceil</script>次磁盘搜索</li>
</ul>
<p>*若任意一个输入关系$r$或$s$未能按属性排序，那么必须先对它们排序。</p>
<h3 id="散列连接（Hash-Join）"><a href="#散列连接（Hash-Join）" class="headerlink" title="散列连接（Hash-Join）"></a>散列连接（Hash-Join）</h3><p>类似于归并连接算法，散列连接算法可用于实现自然连接和等值连接。<br>在散列连接算法中，用散列函数$h$来划分两个关系的元组</p>
<p>基本思想：如果关系$r$的一个元组与关系$s$的一个元组满足连接条件，那么它们在连接属性上就会有相同的值。若该值经散列函数映射到$i$，则关系$r$的那个元组必在$r_i$中，而关系$s$中的元组必在$s_i$中。因此，$r_i$中的元组$r$只需要与$s_i$中的元组$s$相比较，而没有必要与其他任何划分里的元组$s$相比较。</p>
<p>关系$s$被称为<strong>构造用输入（build input）</strong>，关系$r$被称为<strong>探查用输入（probe input）</strong></p>
<p>应选择足够大的$n_h$值，以使对于任意的$i$，内存中可以容纳构造用输入关系的划分$s_i$中的元组以及划分上的散列索引。<br>一般我们使$n = \lceil b_s/M \rceil <em> f$，$f$被称为<em>*避让因子(fudge factor)</em></em>，一般$f$在1.2左右来避开溢出情况。</p>
<p>散列连接的代价：</p>
<ul>
<li>$3(b_r + b_s) + 4 * n_h$ 块传输</li>
<li><script type="math/tex">2(\lceil b_r/ b_b \rceil + \lceil b_s/ b_b \rceil) + 2 * n_h</script>次磁盘搜索</li>
</ul>
<h2 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h2><h3 id="去除重复-Duplicate-Elimination"><a href="#去除重复-Duplicate-Elimination" class="headerlink" title="去除重复(Duplicate Elimination)"></a>去除重复(Duplicate Elimination)</h3><ul>
<li>我们可以用排序方式很容易地实现去除重复：<br>最坏情况去除重复的代价估计与最坏情况对该关系的排序代价估计一样</li>
<li>也可以用散列来实现去除重复：<br>其代价估算与散列连接中构造用输入关系的处理（划分以及读入每个划分）的代价一样</li>
</ul>
<h3 id="投影-Projection"><a href="#投影-Projection" class="headerlink" title="投影(Projection)"></a>投影(Projection)</h3><h3 id="聚集-Aggregation"><a href="#聚集-Aggregation" class="headerlink" title="聚集(Aggregation)"></a>聚集(Aggregation)</h3><p>聚集运算可以用去除重复类似的方法来实现，我们使用排序或散列。但是，我们不是去除在分组属性上有相同值的元组，而是将之聚集成组，并对每一组应用聚集运算以获取结果。<br>如果结果集的元组可以装入内存，则基于排序的实现方法与基于散列的实现方法不必将元组写到磁盘上</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/23/CSE205W4-TransportLayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/23/CSE205W4-TransportLayer/" class="post-title-link" itemprop="url">CSE205W4_TransportLayer</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-23 11:59:11" itemprop="dateCreated datePublished" datetime="2019-09-23T11:59:11+08:00">2019-09-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-30 18:55:33" itemprop="dateModified" datetime="2019-09-30T18:55:33+08:00">2019-09-30</time>
              </span>
            
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><p>运输层协议为运行在<em>不同主机</em>上的<em>应用进程</em>提供了<strong>逻辑通信（logic communication）</strong>功能应用程序使用运输层提供的逻辑通信功能彼此发送报文，而无需考虑承载这些报文的物理基础设施的细节。</p>
<p>运输层协议是在端系统中而不是在网络路由器中实现的：</p>
<ul>
<li>在发送方：运输层将接收到的来自发送应用进程的报文转换成运输层分组，用因特网术语称其为运输层<strong>报文段（segment）</strong>。可能的方法是，将应用报文划分为较小的块，并为每块加上一个运输层首部来创建运输层报文段。然后，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组（一个数据报）并向目的地发送。</li>
<li>在接收方： 网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层则处理接收到的报文段，使得接收方应用进程可应用该报文段中的数据。</li>
</ul>
<p>网络应用程序可以使用多种运输层协议如TCP和UDP</p>
<h3 id="运输层和网络的关系"><a href="#运输层和网络的关系" class="headerlink" title="运输层和网络的关系"></a>运输层和网络的关系</h3><p>在协议栈中，运输层刚好位于网络层之上。<br>运输层为运行在不同主机上的<em>进程</em>之间提供了逻辑通信，而网络层则提供了<em>主机</em>之间的逻辑通信。<br>运输层协议所能提供的服务也受到了底层网络层协议的服务模型的限制。如果网络层协议不能为两主机之间发送的运输层报文段提供时延和带宽保证，那么运输层协议也不能为两进程之间发送的报文提供时延和带宽保证。<br>然而，即使底层网络协议在网络层不提供相应服务，运输层协议也能提供某些服务。一个例子是运输层协议提供可靠性，一个是提供机密性。</p>
<h3 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h3><p>UDP和TCP最基本的任务是，将两个端系统间IP的交付服务扩展为运行在两个端系统上的进程之间的交付服务。将主机间交付扩展到进程间交付，称为<strong>运输层的多路复用和多路分解</strong>。</p>
<ul>
<li>TCP（传输控制协议），它为调用它的应用程序提供了一种可靠的、面向连接的服务<br>TCP为应用程序提供了几种附加服务</li>
</ul>
<ol>
<li>它提供<strong>可靠数据传输（reliable data transfer）</strong>，通过使用流量控制、序号、确认和定时器等技术，TCP确保正确地、按序地将数据从发送进程交付给接收进程。这样，TCP就将两个端系统间不可靠的IP服务转换成了一种可靠的进程间数据传输服务。</li>
<li>TCP还提供<strong>拥塞控制（congestion control）</strong><br>不严格地说，TCP拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。<br>从原理上讲，TCP允许TCP连接通过一条拥塞的网络链路，平等地共享网络链路带宽。</li>
</ol>
<ul>
<li>UDP（用户数据报协议），它为调用它的应用程序提供了一种不可靠、无连接的服务</li>
</ul>
<ol>
<li>UDP流量是不可调节的，使用UDP传输的应用程序可以根据其需要以任何速率发送数据</li>
</ol>
<h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><p><img src="/images/13/13a1.png" alt="运输层的多路复用与多路分解"><br>多路复用与多路分解服务是所有计算机网络都需要的。<br><strong>多路分解（demultiplexing）</strong>：将运输层报文段中的数据交付到正确的套接字的工作。<br><strong>多路复用（multiplexing）</strong>：从源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在多路分解时用到）从而生成报文段，然后将报文段传递到网络层的工作。<br>多路复用的要求：</p>
<ol>
<li>套接字有唯一标示符</li>
<li>每个报文段有特殊字段来指示该报文段所要交付的套接字，这些特殊字段是<strong>源端口号字段（source port number filed）</strong>和<strong>目的端口号字段（destination port number）</strong>。</li>
</ol>
<p>端口号是一个16比特的数字，其大小在0～65535之间。0Q～1023范围的端口号称为<strong>周知端口号（well-known port number）</strong>，是受严格限制的，它们会被保留给诸如HTTP（端口号80）和FTP（端口号21）之类的周知应用层协议。</p>
<p>运输层多路分解的过程：主机上的每个套接字被分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入所连接的进程。。</p>
<ol>
<li><em>无连接的多路复用与多路分解（UDP）</em><br>应用程序的客户机端让运输层自动地（并且透明地）分配端口号，而服务器端则分配一个特定的端口号。<br>一个UDP套接字是由一个包含目的IP地址和目的端口号的二组来全面标识的。如果两个UDP报文段有不同的源IP地址和/或源端口号，但具有相同的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字定向到相同的目的进程。</li>
<li><em>面向连接的多路复用与多路分解</em><br>TCP套接字和UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的。<br>当一个TCP报文从网络到达一台主机时，主机使用全部4个值来将报文段定向（多路分解）到相应的套接字。<br>与UDP不同的是，两个具有不同源IP地址或端口号的到达的TCP报文段将被定向到两个不同的套接字，除非TCP携带了初始创建连接的请求。<br>服务器主机可同时支持很多TCP套接字，每个套接字与一个进程相联系，并由其四元组来标识每个套接字。当一个TCP报文段到达主机时，所有4个字段用来定向（多路分解）报文段到相应的套接字。</li>
</ol>
<h2 id="无连接运输：UDP（User-Datagram-Protocol）-RFC-768"><a href="#无连接运输：UDP（User-Datagram-Protocol）-RFC-768" class="headerlink" title="无连接运输：UDP（User Datagram Protocol）[RFC 768]"></a>无连接运输：UDP（User Datagram Protocol）[RFC 768]</h2><ol>
<li>UDP从应用进程得到数据，附加上多路复用/多路分解服务所需的源端口号和目的端口号字段，及两个其他的小字段，然后将形成的报文段交给网络层。</li>
<li>网络层将该运输层报文段封装到一个IP数据报中，然后尽力而为地将此报文段交付给接收主机。</li>
<li>如果该报文段到达主机，则UDP使用目的端口号来将报文段中的数据交付给正确的应用进程</li>
</ol>
<p>使用UDP时，在发送报文段之前，发送方和接收方的运输层实体之间没有进行握手，正因如此，UDP被称为<strong>无连接</strong>的<br>UDP被使用于DNS连接和流媒体中</p>
<p>UDP的特性：</p>
<ol>
<li><em>应用层能更好地控制将要发送的数据和发送时间：</em></li>
<li><em>无需建立连接：</em>UDP无需任何准备即可进行数据传输，因此UDP不会引入建立连接的时延。</li>
<li><em>无连接状态：</em>TCP需要在端系统中维护连接状态。</li>
<li><em>分组首部开销小：</em>每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的首部开销。</li>
</ol>
<h3 id="UDP报文结构"><a href="#UDP报文结构" class="headerlink" title="UDP报文结构"></a>UDP报文结构</h3><p><img src="/images/13/13a2.png" alt="UDO报文段结构"></p>
<h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p><img src="/images/13/13a3.png" alt="UDp校验和"><br>发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果放在UDP报文段中的<em>检验和</em>字段</p>
<h2 id="可靠数据传输（reliable-data-transfer-protocol）的原理"><a href="#可靠数据传输（reliable-data-transfer-protocol）的原理" class="headerlink" title="可靠数据传输（reliable data transfer protocol）的原理"></a>可靠数据传输（reliable data transfer protocol）的原理</h2><p>通过rdt_send()函数，可以调用数据传输协议的发送方。它将要发送的数据交付给接收方的上层。在接收方，当分组从信道的接收段抵达时，将调用rdt_rcv()。当rdt协议想要向较高层交付数据时，通过调用deliver_data()完成。</p>
<h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><p>通过<strong>有限状态机（finite-state machine，FSM）</strong>来表示发送方和接收方的操作。<br>FSM描述图中各个标志的作用：</p>
<ul>
<li>箭头指示了协议从一个状态便签到另一个状态。</li>
<li>引起变迁的事件显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。<em>如果对一个事件没有采取动作，或没有就事件发生而采取了一个动作，我们将在横线上方或下方使用符号^，以分别明确地表示缺少动作或事件</em></li>
<li>初始状态用虚线表示<h4 id="完全可靠信道上的可靠数据传输：rdt1-0"><a href="#完全可靠信道上的可靠数据传输：rdt1-0" class="headerlink" title="完全可靠信道上的可靠数据传输：rdt1.0"></a>完全可靠信道上的可靠数据传输：rdt1.0</h4><img src="/images/13/13a4.png" alt="rdt1.0:用于完全可靠信道的协议"><br>首先考虑最简单的情况：底层信道是完全可靠的。<br>rdt的发送方只通过rdt_send(data)从较高层接受的数据，产生一个包含该数据的分组（经由make_pkt(data)动作)，并将分组发送到信道中。<br>在接收方，rdt通过rdt_rcv(packet)事件从底层信道接受一个分组，从分组中取出数据（经由extract(packet,data)动作),并将数据上传给高层（通过deliver_data(data)动作）。<br>有了完全可靠的信道，接收方就不需要提供任何反馈信息给发送方，因为不会发生任何差错。<h4 id="具有比特差错信道上的可靠数据传输：rdt2-0"><a href="#具有比特差错信道上的可靠数据传输：rdt2-0" class="headerlink" title="具有比特差错信道上的可靠数据传输：rdt2.0"></a>具有比特差错信道上的可靠数据传输：rdt2.0</h4><img src="/images/13/13a5.png" alt="rdt2.0:用于信道有比特差错的协议"><br>更现实的底层模型是分组中的比特可能受损。<br><strong>肯定确认（positive acknowledgement)</strong>和<strong>否定确认（negative acknowledgement)</strong>。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误从而需要重传。在计算机网络中，基于这种重传机制的可靠数据传输协议称为<strong>自动重传请求(Automatic Repeat reQuest, ARQ)协议</strong>。<br>一般来说，ARQ协议中还需要另外三种协议来处理存在的比特差错：</li>
<li><em>差错检测</em></li>
<li><em>接收方反馈</em></li>
<li><em>重传</em><br>rdt2.0采用了差错检测、肯定确认和否定确认<br>rdt2.0的发送方有两个状态：</li>
<li>发送方协议正等待来自上层的数据。当rdt_send(data)事件发生时，发送方将一个包含带发送数据的分组(sndpkt)，计算出分组校验和，然乎经由udt_send(pkt)操作发送该分组。</li>
<li>发送方协议等待接收方的ACK或NAK分组。如果知道一个ACK分组，则发送方知道最近传输的分组已被正确接收，因此协议返回到等待来自上层数据的状态；如果收到一个NAK分组，该协议重传最后一个分组并等待接收方返回的响应重传分组的ACK或NCK。</li>
</ul>
<p>当发送方在wait-for-ACK-or-NAK状态时，它不能从上层获取数据，因为这种行为，类似于rdt2.0的协议被称为<strong>停等（stop-and-wait)协议</strong></p>
<p>rdt2.0的缺陷：ACK或NAK分组受损，<strong>冗余分组（duplicate packet）</strong>的困难在于接收方不知道它上次所发送的ACK或NAK是否被发送方正确地收到。<br>解决该问题的方法：在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送的数据分组的<strong>序号（sequence number）</strong>放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否是一次重传。<br><img src="/images/13/13a6.png" alt="rdt2.1"><br>协议rdt2.1使用了从接收方到发送方的肯定确认和否定确认。当接收到失序的分组时，接收方对所接受的分组发送一个肯定确认。如果收到受损的分组，接收方将发送一个否定确认。如果不发送NAK，而是发送一个对上次正确接收的分组的ACK，我们也能实现与NAK一样的效果。<br>发送方接收到对同一分组的两个ACK（即接收<strong>冗余ACK，duplicate ACK</strong>）后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。<br><img src="/images/13/13a7.png" alt="rdt2.2"><br>rdt2.2是在具有比特差错信道上实现的一个无NAK的可靠数据协议。<br>rdt2.1和rdt2.2之间的细微变化在于，接收方必须包括由一个ACK报文确认的分组序号（这可以通过在接收方FSM中，包括make_pkt()中的参数ACK，0或ACK，1来实现），发送方必须检查接收到的ACK报文中所确认的分组序号。</p>
<h4 id="具有比特差错的丢包信道上的可靠数据传输：rdt3-0"><a href="#具有比特差错的丢包信道上的可靠数据传输：rdt3-0" class="headerlink" title="具有比特差错的丢包信道上的可靠数据传输：rdt3.0"></a>具有比特差错的丢包信道上的可靠数据传输：rdt3.0</h4><p><img src="/images/13/13a8.png" alt="rdt3.0"><br>现在假定除了比特受损外，底层信道还会<em>丢包</em>。<br>我们让发送方负责检测和恢复丢包。假定发送方传输一个数据分组，或者该分组或者接收方对该分组的ACK发生了丢失。在这两种情况下，发送方都收不到应当到来的接收方的响应。如果发送方愿意等待足够长的时间以便<em>确定</em>分组已丢失，则只需重传该数据分组即可。<br>因此，实际中发送方采取的方法是“明智地”选择一个时间值，以判定确认不能确保但可能已经发生了丢包。如果在这个时间值内没有收到ACK，则重传分组。注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组或ACK都没有丢失。这就是发送方到接收方的信道中引入了<strong>冗余数据分组（duplicate data packet）</strong>的可能性。幸运的是，rdt2.2协议已经有足够的功能（即序号）来处理冗余分组情况。<br>为了实现基于时间的重传机制，需要一个<strong>到计数定时器（countdown timer）</strong>，在一个给定的时间过期后，可中断发送方。<br>因此，发送方需要能做到：1】每次发送一个分组（即第一次分组和重传分组）时，便启动一个定时器。2】响应定时器中断（采取适当的动作）。3】终止定时器。<br>因为分组序号在0和1之间交替，因此rdt3.0有时被称为<strong>比特交替协议（alternating-bit protocol）</strong>。<br><img src="/images/13/13a9.png" alt="rdt3.0比特交替"></p>
<h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><p>rdt3.0的性能问题的核心在于它是一个停等协议。<br>假设两个端系统之间的光速往返传播时延（RTT）大约为30ms。假定彼此通过一条传输速率为$R = 1 Gbps(10^9 bps)的信道相连。包括首部字段和数据的分组长$L = 1000$字节（8000比特），实际发送一个分组到$1Gbps$链路中所需时间是：</p>
<script type="math/tex; mode=display">
t_{trans} = \frac{L}{R} = \frac{8000bit/packet}{10^9bit/s} = 8 \mu s</script><p>如果发送方在$t = 0$时刻开始发送分组，则在$t = L/R = 8\mu s$后，最后1比特数据进入发送方信道。该分组经过15ms跨美国的旅行后到达接收方，该分组在时刻$t = RTT/2 + L/R = 15.008ms$时到达接收方。为了简化起见，假设ACK分组很小（以便我们可以忽略其发送时间）。接收方收到一个数据分组的最后1比特后立即发送ACK，ACK在时刻$t = RTT + L/R =30.008ms时到达发送方。此时，发送方可以发送下一个报文。<br>因此在30.008ms内，发送方的发送只用了0.008ms。定义发送方（或信道）的<strong>利用率（utilization)</strong>为：发送方实际忙着将发送比特送进信道的时间与发送时间之比。</p>
<script type="math/tex; mode=display">
U_{sender} = \frac{L/R}{RTT+L/R} = \frac{0.008}{30.008} = 0.00027</script><p><img src="/images/13/13a10.png" alt="rdt3.0的信道利用率"><br>解决这种特殊的性能问题的一个简单方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。因为从发送方向接收方传输的众多分组可以被看成是填充到一条流水线中，故这种技术被称为<strong>流水线（pipelining）</strong>。流水线技术可对可靠数据传输协议带来如下影响：</p>
<ol>
<li>必须增加序号范围，因为每个传输的分组（不算重传的）必须有一个唯一的序号，而且也许有多个在传输中未确认的分组。</li>
<li>协议的发送方和接收方也许必须缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议处理丢失、损坏及过度延时分组的方式。解决流水线的差错恢复有两种基本方法：<strong>回退N步（Go-Back-N)</strong>和<strong>选择重传(selective repeat)</strong></li>
</ol>
<p>1、什么叫做将两个端系统间IP的交付服务扩展为运行在两个端系统上的进程之间的交付服务？<br>2】rdt传送的是什么？<br>3】rdt2.1和rdt2.2的区别</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/19/CSE201W3-HashIndex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/19/CSE201W3-HashIndex/" class="post-title-link" itemprop="url">CSE201W3_HashIndex</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-19 11:57:47 / Modified: 17:37:39" itemprop="dateCreated datePublished" datetime="2019-09-19T11:57:47+08:00">2019-09-19</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="静态散列（Static-Hashing）"><a href="#静态散列（Static-Hashing）" class="headerlink" title="静态散列（Static Hashing）"></a>静态散列（Static Hashing）</h2><p>顺序组织文件的一个缺点是我们必须访问索引结构来定位数据，或者必须使用二分法搜索，这将导致过多的I/O操作。基于<strong>散列（hashing）</strong>技术的文件组织使我们能够避免访问索引结构。<br>在对散列的描述中，我们将使用术语<strong>桶（bucket）</strong>来表示能存储一条或多条记录的一个储存单位，通常一个桶就是一个磁盘块，但也可能小于或大于一个磁盘块。<br>令$K$表示所有搜索码值的集合，令$B$表示所有桶地址的集合，<strong>散列函数（hashing function）</strong>$h$是一个从$K$到$B$的函数。<br>不同搜索码值可能被存储到同一个桶中，因此，我们必须检查桶中每条记录的搜索码值，以确定该记录是否是我们要查找的记录。</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>最坏的可能是散列函数把所有搜索码值映射到同一桶中。<br>具有下列分布特性的散列函数是我们理想中想建成的：</p>
<ul>
<li><em>分布是均匀的</em>。即散列函数从所有可能的搜索码值集合中为每个桶分配同样数量的搜索码值</li>
<li><em>分布是随机的</em>。即在一般情况下，不管搜索码值实际怎样分布，每个桶应分配到的搜索码值数目几乎相同。散列函数应该表现为随机的。</li>
</ul>
<p>通常散列函数在搜索码中字符的内部二进制机器表示上执行计算。这种类型的一个简单函数是先计算码中字符的二进制表示的总和，然后返回该总和取桶数目的模。</p>
<h3 id="桶溢出处理（bucket-overflow）"><a href="#桶溢出处理（bucket-overflow）" class="headerlink" title="桶溢出处理（bucket overflow）"></a>桶溢出处理（bucket overflow）</h3><p>如果桶没有足够的空间，就会发生<strong>桶溢出</strong>，桶溢出的发生可能有以下几个原因：</p>
<ul>
<li><strong>桶不足</strong></li>
<li><strong>偏斜</strong>偏斜发生的原因可能有两个：1）多条记录可能具有相同的搜索码。2）所选的散列函数可能会造成搜索码的分布不均。</li>
</ul>
<p>尽管分配的桶比所需的桶多一些，但是桶溢出还是可能发生。我们用<strong>溢出桶（overflow bucket）</strong>来处理桶溢出问题。如果一条记录必须插入桶$b$中，而桶$b$已满，系统会为桶$b$提供一个溢出桶，并将此记录插入到这个溢出桶中。如果溢出桶也满了，系统会提供另一个溢出桶。</p>
<p>一个给定桶的所有溢出桶用一个链接列表链接在一起，使用这种链接列表的溢出处理称为<strong>溢出链（overflow chaining）</strong>。<br><img src="/images/12/12a1.png" alt="散列结构中的溢出链"></p>
<h3 id="散列索引（Hash-Indices）"><a href="#散列索引（Hash-Indices）" class="headerlink" title="散列索引（Hash Indices）"></a>散列索引（Hash Indices）</h3><p>散列不仅可以用于文件组织，还可以用于索引结构的创建。<strong>散列索引</strong>将搜索码及其相应的指针组织成散列文件结构。<br>我们将散列函数作用于搜索码以确定对应的桶，然后将此搜索码以及响应指针存入此桶（或溢出桶）中。<br>严格地说，散列索引只是一种辅助索引结构。如果一个文件自身是按 散列组织的，就不必在其上另外建立一个独立的索引结构。<br>我们用术语<em>散列索引</em>来表示散列文件结构和辅助散列索引。</p>
<h3 id="静态散列的缺点"><a href="#静态散列的缺点" class="headerlink" title="静态散列的缺点"></a>静态散列的缺点</h3><p>如果我们为会随时间变大的数据库使用静态散列时会有三种选择：</p>
<ol>
<li>根据当前文件大小选择散列函数。这种选择会使性能随数据库的增大而下降</li>
<li>根据将来某个时刻文件的预计大小选择散列函数。尽管这样可以避免性能下降，但是初始会造成相当大的空间浪费。</li>
<li>随着文件增大，周期性地对散列结构进行重组。但重组是一个规模大、耗时的操作，而且重组期间必须禁止对文件的访问。</li>
</ol>
<h2 id="动态散列"><a href="#动态散列" class="headerlink" title="动态散列"></a>动态散列</h2><p>几种<strong>动态散列</strong>技术允许散列函数动态改变，以适应数据库增大或缩小的需要。这里介绍的是<strong>可扩充散列（extendable hashing）</strong>。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>使用可扩散序列时，我们选择一个具有均匀性和随机特性的散列函数$h$。但是，此散列函数产生的值范围相对较大，是$b$位二进制整数。一个典型的$b$值是32.<br>开始时，我们并不使用散列值的全部$b$，任意时刻我们使用的位数$i$满足$0 \leq i \leq b$。这个的$i$个位用作附加的桶地址表中的偏移量。$i$的值随着数据库大小的变化而增大或减小。<br>几个连续的表项可能指向同一个桶。所有这样的表项有一个共同的散列前缀，但这个前缀的长度可能小于$i$。因此，我们给每一个桶附加一个整数值，用来表明<strong>共同的散列前缀长度</strong>，桶地址中指向桶的表项编号为</p>
<script type="math/tex; mode=display">
2^{i-i_j}</script><h3 id="查询和更新"><a href="#查询和更新" class="headerlink" title="查询和更新"></a>查询和更新</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>为了确定含有搜索码$K_l$的痛的位置，系统取得$h(K_l)$的前$i$个高位，然后为这个位串查找对应的表项，再根据表项中的指针得到桶的位置。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>要插入一条搜索码值为$k_l$的记录，系统按上述相同过程进行查找，最终定位到某个桶$j$，如果该桶中有剩余空间，系统将该记录插入该桶即可；若桶$j$已满，系统必须分裂该桶，系统需首先根据散列值确定是否需要增加所使用的位数</p>
<ul>
<li>如果$i = i_j$，那么在桶地址中只有一个表项 指向桶$j$。所以系统需要增加桶地址表的大小，系统考虑多引入散列值的一位。系统将$i$的值加1，从而使桶地址表的大小加倍。<br>*如果桶$j$中所有记录搜索码值相同，那么分裂多少次也不能解决问题。在这种情况下，采用溢出桶来储存记录，就像在静态散列中那样。</li>
<li>如果$i &gt; i_j$，那么在桶地址中表中有多个表项指向桶$j$。因此，系统不需要扩大桶地址表就能分裂桶j。<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4>要删除一条搜索码值为$K_l$的记录，系统可以按照前面的查找过程找到相应的桶$j$，系统不仅要把搜索码从桶中删除，还要把记录从文件中删除。如果此时桶为空，那么桶也要删除。注意⚠️，此时某些桶可能合并，桶地址表的大小也可能减半。</li>
</ul>
<h3 id="静态散列和动态散列的比较"><a href="#静态散列和动态散列的比较" class="headerlink" title="静态散列和动态散列的比较"></a>静态散列和动态散列的比较</h3><p>可扩充散列最主要的优点：</p>
<ul>
<li>其性能不随文件的增长而降低</li>
<li>其空间开销是最小的</li>
</ul>
<p>可扩充散列的缺点：</p>
<ul>
<li>查找涉及一个附加的简介层</li>
<li>桶地址表可能会变得十分巨大</li>
<li>改变桶地址表的大小是非常昂贵的操作</li>
</ul>
<h2 id="顺序索引和散列的比较"><a href="#顺序索引和散列的比较" class="headerlink" title="顺序索引和散列的比较"></a>顺序索引和散列的比较</h2><p>文件可以被组织为</p>
<ul>
<li>$B^+$树组织或索引顺序组织将记录文件组织成顺序文件</li>
<li>散列</li>
<li>堆文件</li>
</ul>
<p>要对关系的文件组织和索引技术做出明智的选择，实现者或数据者必须考虑以下问题：</p>
<ul>
<li>索引或散列组织的周期性重组代价是否可以接受？</li>
<li>插入和删除的相对频率如何？</li>
<li>是否愿意以增加最坏情况下的访问时间为代价优化平均访问时间？</li>
<li>用户可能提出哪些类型的查询？</li>
</ul>
<p>散列文件组织和散列索引的区别？</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/16/CSE205W3-ApplicationLayer-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/16/CSE205W3-ApplicationLayer-2/" class="post-title-link" itemprop="url">CSE205W3_ApplicationLayer(2)</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-16 10:55:22" itemprop="dateCreated datePublished" datetime="2019-09-16T10:55:22+08:00">2019-09-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-19 11:30:21" itemprop="dateModified" datetime="2019-09-19T11:30:21+08:00">2019-09-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="DNS-因特网的目录服务"><a href="#DNS-因特网的目录服务" class="headerlink" title="DNS: 因特网的目录服务"></a>DNS: 因特网的目录服务</h2><p>主机的一种识别方法是用它的<strong>主机名（hostname）</strong>，如cnn.com，但主机名提供了很少关于主机在因特网中的信息。因为主机名可能由不定长的字母数字组成，所以路由器很难处理。<br>基于上述原因，主机也可以用<strong>IP地址（IP address）</strong>进行识别。</p>
<h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>DNS协议是应用层协议，它使用客户机/服务器模式在通信的端系统之间运行，在通信的端系统之间通过下面的端到端运输层协议来传输DNS报文。<br>然而在某种意义上，DNS的作用非常不同于Web应用、文件传输应用以及电子邮件应用。不同之处在于，DNS并不直接和用户打招呼。相反，DNS为因特网上的用户应用程序以及其他软件提供一种核心功能，即将主机名转换为它们下面的IP地址。</p>
<p>有两种方式识别主机：通过主机名或者IP地址。人们喜欢便于记忆的主机名标示，而路由器则喜欢定长的、有着层次结构的IP结构。<strong>域名系统（Domain Name System，DNS）</strong>的主要任务就是进行主机名到IP地址转换的目录服务。</p>
<p>DNS是一个由<em>分层</em>的<strong>DNS服务器（DNS server）</strong>实现的分布式数据库。DNS是一个允许主机查询分布式数据库的应用层协议。</p>
<p>DNS所提供的服务：</p>
<ul>
<li>主机名到IP地址的转换</li>
<li><strong>主机别名（host aliasing）</strong>。有着复杂主机名的主机可以拥有一个或多个别名，应用程序可以调用DNS来获得主机别名对应的规范主机名及主机的IP地址。</li>
<li><strong>邮件服务器别名（mail server aliasing）</strong>。电子邮件应用程序调用DNS，对提供的邮件服务器别名进行解析，以获得该主机的规范主机名及其IP地址。</li>
<li><strong>负载分配（load distribution）</strong><br>DNS也用在冗余的服务器（如冗余的Web服务器等）之间进行负载分配。<h3 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h3>DNS的一种简单设计方式是在因特网上只使用一个DNS服务器，该服务器包含所有的映射。在这种集中式设计中，客户机直接将所有查询直接发往单一的DNS服务器，同时该DNS服务器直接对所有的查询客户机做出响应。尽管这种设计方式非常具有吸引力，但它不适用于当今的因特网，因为因特网有着数量巨大（并持续增长）的主机。这种集中式设计的问题包括：</li>
<li><strong>单点故障（a single point of failure)</strong>：如果该DNS服务器故障，整个因特网将随之瘫痪</li>
<li><strong>通信容量（traffic volume)</strong>：单个DNS服务器不得不处理所有的DNS查询</li>
<li><strong>远距离的集中式数据库（distant centralized database)</strong>：查询的地理距离会导致严重的时延</li>
<li><strong>维护（maintenance)</strong>：在单一DNS服务器上运行集中式数据库完全没有可扩展能力<h4 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h4><img src="/images/11/11a1.png" alt="DNS服务器的部分层次结构"><br>为了处理规模问题，DNS使用了大量的DNS服务器，它们以层次方式组织，并分布在全世界范围内。<br>有3种类型的DNS服务器：</li>
<li><strong>根服务器（root name servers)</strong></li>
<li><strong>顶级域（Top-level domain, TLD）服务器</strong>:<br>这些服务器负责顶级域名（如com、org、net、edu和gov）和所有国家的顶级域名（如uk、fr、ca和jp）</li>
<li><strong>权威DNS服务器（Authoritative DNS servers)</strong>:<br>在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构的权威DNS服务器负责保存这些记录。</li>
</ul>
<p>假定一个DNS客户机要确定主机名www.amazon.com的IP地址。粗略来说将发生以下事件。该客户机首先与根服务器之一联系，它将返回顶级域名com的TLD服务器的IP地址。该客户机则与这些TLD服务器之一联系，它将为amazon.com返回权威服务器的IP地址。最后，该客户机为amazon.com联系权威服务器之一，他为主机名www.amazon.com返回IP地址。</p>
<p>还有另一类很重要的DNS，称为<strong>本地DNS服务器（local DNS server）</strong>。<br>本地服务器严格来说并不属于DNS服务器的层次结构，但它对DNS层次结构是很重要的。<br>主机的本地DNS服务器通常“临近”本主机。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中。<br><img src="/images/11/11a2.png" alt="各种DNS服务器的交互"><br>在本例中，为了获得一个主机名的映射，共发送了8份报文：4份查询报文和4份回答报文。<br>本例中也使用了<strong>递归查询（recursive query）</strong>和<strong>迭代查询（iterative query）</strong>。查询通常按照该例子中的模式：从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。</p>
<h4 id="DNS缓存（DNS-caching）"><a href="#DNS缓存（DNS-caching）" class="headerlink" title="DNS缓存（DNS caching）"></a>DNS缓存（DNS caching）</h4><p>为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术。<br>在请求链中，当一个DNS服务器接收一个DNS回答（例如，包含主机名到IP地址的映射）时，DNS服务器能将回答中的信息缓存在本地存储器。如果在DNS服务器中缓存了一个主机名/IP地址对，另一个相同主机名的查询到达该DNS服务器时，该服务器能够提供所要求的IP地址，即使它不是该主机名的权威服务器。<br>由于主机和主机名与IP地址间的映射决不是永久的，所以DNS服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。<br>本地DNS服务器也可以缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根服务器（这经常发生）。</p>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>实现DNS分布式数据库的所有DNS服务器共同存储着<strong>资源记录（Resource Record, RR)</strong>，RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记录。<br>资源记录是一个包含了下列字段的四元组：(Name, Value, Type, TTL)<br>TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。<br>Name和Value的值取决于Type：</p>
<ul>
<li>如果Type=A，则Name是主机名，Value是该主机名的IP地址。因此，一条类型为A的资源记录提供了标准的主机名到IP地址的映射。</li>
<li>如果Type=NS，则Name是域，而Value是知道如何获得该域中主机IP地址的权威DNS服务器的主机名，这个记录用于沿着查询链路进一步路由DNS查询。</li>
<li>如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名</li>
<li>如果Type=MX，则Value是别名为Name的邮件服务器的规范主机名。MX记录允许邮件服务器的主机名具有简单的别名。通过使用MX记录，一个公司的邮件服务器和其他服务器（如它的Web服务器）可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS客户机应当请求一条CNAME记录。</li>
</ul>
<h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p>DNS只有查询和回复报文，并且，查询和回答报文有着相同的格式。<br><img src="/images/11/11a3.png" alt="DNS报文格式"><br>DNS报文中各字段的语义如下：</p>
<ul>
<li>前12个字节是<em>首部</em>区域，其中有几个字段。<br>第一个字段是一个16比特的数，用于标示该查询。这个标识符会被复制到对查询的回答报文中，以便让客户机用它来匹配发送的请求和接收到的回答。标志字段中含有若干标志。<br>1比特的“查询/回答”标志位指出报文是查询报文（0）还是回答报文（1）。<br>在该首部还有4个“数量”字段，这些字段指出了在首部后4类数据区域出现的数量。</li>
<li><em>问题区域</em>包含着正在进行的查询信息。该区域包括：1）名字字段，用于指出正在被查询的主机名字；2）类型字段，用于指出正被询问的问题类型。</li>
<li>在来自DNS服务器的回答报文中，<em>回答区域</em>包含了对最初请求的名字的资源记录。在一个回答报文的回答区域中可以包含多条RR，因为一个主机名可以对应多个IP地址。</li>
<li><em>权威区域</em>包含了其他权威DNS服务器的记录</li>
<li><em>附加区域</em>包含了一些其他有帮助的信息。</li>
</ul>
<h4 id="在DNS数据库中插入记录"><a href="#在DNS数据库中插入记录" class="headerlink" title="在DNS数据库中插入记录"></a>在DNS数据库中插入记录</h4><p>首先要做的事情是在注册登记机构注册域名。<strong>注册登记机构（registrar）</strong>是一个商业实体，它验证域名的唯一性，将域名输入DNS数据库，对所提供的服务收取少量费用。<br>向某些注册登记机构注册域名的时候，需要向该机构提供你基本的权威DNS服务器和辅助权威DNS服务器的名字和IP地址。<br>你也必须确保用于Web服务器的类型A资源记录和用于邮件服务器的类型MX资源记录被输入你的权威DNS服务器中。</p>
<h4 id="DNS攻击"><a href="#DNS攻击" class="headerlink" title="DNS攻击"></a>DNS攻击</h4><ol>
<li>DDoS带宽洪泛攻击，攻击者能够向每个DNS根服务器连续不断地发送大量的分组，从而使大多数合法DNS攻击请求得不到回答。</li>
<li>更有效的DDoS攻击是向顶级域名服务器发送大量的DNS请求。这是因为更难过滤指向DNS服务器的DNS请求，并且顶级域名服务器不像根服务器那样容易被绕过</li>
<li>中间人攻击，攻击者截获来自主机的请求并返回伪造的回答。</li>
<li>DNS毒害攻击，攻击者向DNS服务器发送伪造的回答，诱使服务器在其缓存中保存伪造的记录。3和4难以实现，因为他们要求截获分组或遏制服务器。</li>
<li>充分利用DNS基础设施来对目标主机发起DDoS攻击。在这种攻击中，攻击者向许多权威DNS服务器发送DNS请求，每个请求带有目标主机的假冒源地址。</li>
</ol>
<h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><p>我们通过讨论从单一服务器向大量主机（对等方）分发大文件这个应用来研究P2P<br>在客户机/服务器文件分发中，服务器必须向每个对等方发送该文件的一个拷贝，及服务器承担了极大的负担，并且消耗了大量的服务器带宽。<br>在P2P文件分发中，每个对等方都能够重新分发其所有的该文件的任何部分，从而协助服务器进行分发。</p>
<h4 id="P2P体系结构的扩展性"><a href="#P2P体系结构的扩展性" class="headerlink" title="P2P体系结构的扩展性"></a>P2P体系结构的扩展性</h4><p>我们假设服务器和对等方使用接入链路与因特网相连。其中$u_s$表示服务器接入链路的上载速率，$u_i$表示第$i$个对等方接入链路的下载速率。此外$F$表示被分发的文件长度（以比特计），$N$表示要获得文件拷贝的对等方的数量。<br><strong>分发时间（distribution time）</strong>是$N$个对等方得到文件拷贝所需要的时间。我们可以根据课本上的推导（足够详细）得到</p>
<ol>
<li>客户机/服务器体系结构中的分发时间<script type="math/tex; mode=display">
D_{cs} \geq max\left\{NF/u_s,F/d_{min}\right\}</script>我们取下界为实际分发时间，即<script type="math/tex; mode=display">
D_{cs} = max\left\{NF/u_s,F/d_{min}\right\}</script></li>
<li>在P2P体系结构中，每个对等方都可以帮助服务器来分发文件，也就是说，当一个对等方接收到文件数据的时候，它可以利用自己的上载能力重新将数据分发给其他对等方。<br>P2P体系结构的分发时间<script type="math/tex; mode=display">
D_{P2P} \geq max\left\{F/u_s,F/d_{min},NF/(u_s + \sum_{i=1}^N u_i)\right\}</script>我们取下界为实际的分发时间，即<script type="math/tex; mode=display">
D_{P2P} = max\left\{F/u_s,F/d_{min},NF/(u_s + \sum_{i=1}^N u_i)\right\}</script><img src="/images/11/11a4.png" alt="P2P和客户机/服务器体系结构的分发时间"><br>上图中我们设置了<script type="math/tex">F/U = 1</script>小时，<script type="math/tex">u_s = 10u</script>, <script type="math/tex">d_{min} \geq u_s</script>。<br>对于客户机/服务器体系结构，随着对等方数量的增长，分发时间呈线性增长并且没有界。对于P2P体系结构，最小分发时间不仅总是小于客户机/服务器体系结构的分发时间，而且对任何多的对等方其总是小于1小时。因此采用P2P体系结构是可以拓展的，因为对等方除了是比特的消费者外还能重新分发。<h4 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h4>BitTorrent是一种用于文件分发的流行P2P协议。用BitTorrent的术语来讲参与一个特定文件分发的所有对等方的一个集合称为一个<em>洪流（torrent）</em>。<br>在一个洪流中，对等方彼此下载等长度的<em>文件块</em>，块长度通常为256KB。<br>每个洪流具有一个基础设施节点，称为<em>追踪器（tracker）</em>。当一个对等方加入洪流时，它向追踪器注册，并周期性地通知追踪器它仍在洪流中。<br>当一个新的对等方Alice加入洪流时，追踪器随机地从参与对等方集合中选择一些对等方Alice持有对等方的这张列表，试图与该列表上的对等方创建并行的<strong>TCP连接</strong>。所有与Alice成功地创建连接的对等方为“临近对等方”，临近对等方将随着时间而改变。<br>在任何时刻，每个对等方都具有来自某文件块的自集。Alice周期性地（经TCP）连接询问每个临近对等方它们所具有的块列表，Alice将对她目前还没有的块发出请求（仍通过TCP连接）。<br>Alice将做出两个重要的决定：</li>
<li>她应当向她的邻居请求哪些块呢？<br>Alice使用一种<strong>最稀罕优先（rarest first）</strong>的技术。这种技术的思路是：根据她没有的块从她的邻居中确定最稀罕的块（就是在她的邻居中拷贝数量最少的那些块），并优先请求那些最稀罕的块。</li>
<li>她请求的块应当发送给她的哪些邻居<br>为了决定Alice响应哪个请求，其基本想法是Alice确定其邻居的优先权，这些邻居是那些当前能以<em>最高的速率</em>给她数据的。</li>
</ol>
<p>1】递归迭代？<br>2】分布式数据库<br>3】Type = NS？</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/14/CSE201W2b-B-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/14/CSE201W2b-B-Tree/" class="post-title-link" itemprop="url">CSE201W2b_B+Tree</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-14 19:14:24" itemprop="dateCreated datePublished" datetime="2019-09-14T19:14:24+08:00">2019-09-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-17 20:53:06" itemprop="dateModified" datetime="2019-09-17T20:53:06+08:00">2019-09-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p><strong>$B^+$树（$B^+$-tree）</strong>索引结构是在数据插入和删除下仍能保持其执行效率的几种使用最广泛的索引结构之一。B+树采用<strong>平衡树（balanced tree）</strong>结构</p>
<h2 id="B-树的基本要求"><a href="#B-树的基本要求" class="headerlink" title="B+树的基本要求"></a>B+树的基本要求</h2><p>B+树结点最多包含$n - 1$个搜索码值<script type="math/tex">K_1, K_2, ..., K_{n-1}</script>，以及$n$个指针<script type="math/tex">P_1, P_2, ..., P_n</script>,每个结点的搜索码值排序存放。<br><strong>根结点（root）</strong>必须至少有两个子结点<br>在每个<strong>非叶结点（nonleaf node）</strong>至少容纳$\lceil n/2 \rceil$个指针<br>在每个<strong>叶结点（leaf node）</strong>至少容纳$\lceil (n-1)/2 \rceil$个搜索值<br>一个B+树的高度不得超过<script type="math/tex">\lceil log_{\lceil n/2 \rceil} (K) \rceil</script></p>
<h2 id="B-树的查询"><a href="#B-树的查询" class="headerlink" title="B+树的查询"></a>B+树的查询</h2><p><img src="/images/10/10a1.png" alt="B+树的查询"></p>
<h2 id="B-树的更新"><a href="#B-树的更新" class="headerlink" title="B+树的更新"></a>B+树的更新</h2><p><img src="/images/10/10a2.png" alt="B+树的更新"></p>
<ul>
<li><strong>Splitting a leaf node</strong>：</li>
</ul>
<ol>
<li>将$n$个搜索码值和指针（包括插入的）放入一个可以存放的区域$M$，将前$\lceil n/2 \rceil$放入原先的结点，将剩余的放入一个新结点</li>
<li>将新结点视为$p$，将该结点内最小的搜索码值视为$k$，将$(k,p)$放入父结点</li>
<li>如果父结点也满了，就顺级分离。</li>
</ol>
<ul>
<li><strong>Splitting a non-leaf node</strong>:<br>当插入搜索码值和指针到一个已经没有位置的非叶结点$N$时</li>
</ul>
<ol>
<li>将$N$放到一个可以储存$n$个搜索码值和$n+1$个指针的区域$M$</li>
<li>将要插入的$(k,p)$按照排列插入$M$中</li>
<li>将<script type="math/tex">P_1, K_1, ..., K_{\lceil n/2 \rceil - 1}, P_{\lceil n/2 \rceil}</script>从$M$抄写到原来的$N$中</li>
<li>将<script type="math/tex">P_{\lceil n/2 \rceil+1}, K_{\lceil n/2 \rceil+1}, ..., K_n, P_{n+1}</script>从$M$抄写到新的非叶结点$N’$</li>
<li>将(<script type="math/tex">K_{\lceil n/2 \rceil}</script>, $N’$)写到父结点中。</li>
</ol>
<p><em>分离结点的最差情况是整体高度+1</em><br><img src="/images/10/10a3.png" alt="Insertion例子"></p>
<h2 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h2><ul>
<li>删除后，如果该结点的搜索码值过于少，并且该结点可以和它的兄弟结点相结合成一个结点，我们使用<strong>merge siblings</strong>:</li>
</ul>
<ol>
<li>将两个结点的所有搜索值码放入一个搜索值码中，并删除另一个结点。</li>
<li>如果它是一个非叶结点，将两个结点中的父节点拷贝到结合的结点中</li>
<li>将（<script type="math/tex">K_{i-1}, P_i</script>）从父节点中删除，$P_i$是指向原先存在结点的指针，重复上述过程</li>
</ol>
<ul>
<li>删除后，如果该结点的搜索码值过于少，但是又不能和它的兄弟结点相结合成为一个结点，我们使用<strong>redistribute pointers</strong>:</li>
</ul>
<ol>
<li>重新分配它和它兄弟结点的指针使这两个结点都满足最少搜索码值的要求，更新父节点中的搜索码值</li>
<li>如果是<strong>叶结点</strong>：将一个适合的搜索码值从它的兄弟结点中移到该结点里，将父节点中的旧搜索码值替换为合适的搜索码值</li>
<li>如果是<strong>非叶结点</strong>：将父节点中的旧搜索码放入不满的结点中，将一个合适的搜索码值从兄弟结点中移到父节点中。<br><img src="/images/10/10a4.png" alt="Deletion例子1"><br><img src="/images/10/10a5.png" alt="Deletion例子2"><br><img src="/images/10/10a6.png" alt="Deletion例子3"></li>
</ol>
<p>level below root?</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/13/CSE201W2a-Indexing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/13/CSE201W2a-Indexing/" class="post-title-link" itemprop="url">CSE201W2a_Indexing</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-13 22:39:02" itemprop="dateCreated datePublished" datetime="2019-09-13T22:39:02+08:00">2019-09-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-15 15:08:24" itemprop="dateModified" datetime="2019-09-15T15:08:24+08:00">2019-09-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="索引的基本概念"><a href="#索引的基本概念" class="headerlink" title="索引的基本概念"></a>索引的基本概念</h2><p>索引技术用来加快得到所需数据的时间</p>
<p>有两种基本的索引类型</p>
<ul>
<li><strong>顺序索引（an ordered Index）</strong>：基于值的顺序排序</li>
<li><strong>散列索引（a hashing Index）</strong>：基于将值平均分布到若干散列桶中，一个值所属的散列桶是由一个函数决定的，该函数称为散列函数（hash function）。</li>
</ul>
<p>我们将考虑用于顺序索引和散列索引的几种技术。没有哪一种技术是最好的，只能说某种技术对特定的数据库应用是最适合的。对每种技术的评价必须基于下面这些因素：</p>
<ul>
<li><strong>访问类型（access type）</strong>：能有效地支持的访问类型。访问类型可以包括找到具有特定属性值的记录，以及找到属性值落在某个特定范围内的记录。</li>
<li><strong>访问时间（access time）</strong></li>
<li><strong>插入时间（insertion time）</strong></li>
<li><strong>删除时间（deletion time）</strong></li>
<li><strong>空间开销（space overhead）</strong></li>
</ul>
<p>用于在文件中查找记录的属性或属性集称为<strong>搜索码（search key）</strong>。如果一个文件上有多个索引，那么它就有多个搜索码。</p>
<h2 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h2><p>顺序索引按顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。<br>如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为<strong>聚集索引（clustering index）</strong>，聚集索引也被称为<strong>主索引（primary index）</strong>：主索引可以建立在任何搜索码上，一般是主搜索码。<br>搜索码指定的顺序与文件中记录的物理顺序不同的索引称为<strong>非聚集索引（nonclustering index）</strong>或<strong>辅助索引（secondary index）</strong><br>搜索码上有聚集索引的文件称为<strong>索引顺序文件（index-sequential file）</strong></p>
<h3 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h3><p><strong>索引项（index entry）</strong>或<strong>索引记录（index record）</strong>由一个搜索码值和指向具有该搜索码值的一条或多条记录的指针构成。指向记录的指针包括磁盘块的标示和标示磁盘块的内部偏移量。</p>
<ul>
<li><strong>稠密索引（dense index）</strong><br>在稠密索引中，文件中的每个搜索码值都有一个索引项.具有相同搜索码值的其余记录顺序地储存在第一条数据记录之后。<br>在稠密非聚集索引中，索引必须储存指向所有具有相同搜索码值的记录的指针列表</li>
<li><strong>稀疏索引（sparse index）</strong><br>在稀疏索引中，只为搜索码的某些值（一般是一个块一个）建立索引项。<strong>只有当关系按搜索码排列顺序储存时才能使用稀疏索引。</strong><br>为了定位一条记录，我们找到其最大搜索码值小于或等于所查找记录的搜索码值的索引项。然后从该索引项指向的记录开始，沿着文件中的指针查找，直到找到所需记录为止。</li>
</ul>
<p>利用稠密索引通常可以比稀疏索引更快地定位一条记录。但是，稀疏索引也有比稠密索引优越的地方：它所占空间较小，并且插入和删除时所需的维护开销也较小。<br><img src="/images/9/9a1.png" alt="稠密索引和稀疏索引的比较"></p>
<h3 id="辅助索引（Secondary-Index）"><a href="#辅助索引（Secondary-Index）" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h3><p><strong>辅助索引必须是稠密索引。</strong><br>候选码上的辅助索引看起来和稠密聚集索引没有太大的区别，只不过索引中一系列的连续值指向的记录不是连续存放的。<br>我们可以用一个附加的间接指针层来实现非候选码的搜索码上的辅助索引。在这样的辅助索引中，指针并不指向文件，而是指向一个包含文件指针的桶。<br>如果文件具有多个索引，无论何时修改文件，它的每个索引都必须更新？<br>用辅助索引的顺序扫描较为昂贵，每个记录也许都要从一个新的数据块中提取。</p>
<h3 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h3><p>如果索引小到可以放到主存里，搜索一个索引项的时间就会很短。<br>但是如果索引过大而不能放到主存中，那么当需要时，就必须从磁盘中取出索引块。于是一次搜索需要多次读取磁盘块。<br>解决该问题，我们在原始的内层索引上构造一个稀疏的外层索引，索引项是有序的，这使得外层索引可以是稀疏的。<br>如果文件极其庞大，甚至外层索引也可能达到不能装入主存，可以创建另一级索引。事实上，可以根据需要多次重复该过程。具有两级或两级以上的索引称为<strong>多级（multilevel）</strong>索引。<br>多级索引的插入和删除：在插入和删除时，系统对底层索引更新和普通的一样，接下来的每一层都要随之改变。</p>
<p>1】每个索引都必须更新？</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/09/CSE205W2-ApplicationLayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/09/CSE205W2-ApplicationLayer/" class="post-title-link" itemprop="url">CSE205W2_ApplicationLayer</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-09 13:10:18" itemprop="dateCreated datePublished" datetime="2019-09-09T13:10:18+08:00">2019-09-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-15 15:08:39" itemprop="dateModified" datetime="2019-09-15T15:08:39+08:00">2019-09-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><p>研究网络应用程序核心是能够运行在不同的端系统和通过网络彼此通信的程序。（Write programs that: Run on different end systems and Communicate over network.）<br>重要的是，你不用写在网络核心设备（如路由器或链路层交换机）上运行的软件。</p>
<h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><h3 id="客户机-服务器体系结构（client-server-architecture）"><a href="#客户机-服务器体系结构（client-server-architecture）" class="headerlink" title="客户机/服务器体系结构（client-server architecture）"></a>客户机/服务器体系结构（client-server architecture）</h3><ul>
<li>服务器（server)</li>
</ul>
<ol>
<li>在客户机/服务器体系结构中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为<em>客户机</em>的主机请求。</li>
<li>服务器具有固定的、周知的地址，称为IP地址</li>
<li>服务器的性能优异</li>
</ol>
<ul>
<li>客户机（clients）</li>
</ul>
<ol>
<li>服务器需要服务来自于许多客户机的主机请求</li>
<li>客户机主机既可能有时打开，也可能总是打开</li>
<li>客户机相互之间不直接通信</li>
<li>可能间歇性地与网络相连</li>
<li>可能拥有动态的地址</li>
</ol>
<h3 id="P2P体系结构（P2P-architecture"><a href="#P2P体系结构（P2P-architecture" class="headerlink" title="P2P体系结构（P2P architecture)"></a>P2P体系结构（P2P architecture)</h3><p>在<em>P2P体系结构</em>中，对总是打开的基础设施服务有最小的（或者没有依赖）。相反，任意间断连接的主机——称为对等方，直接相互通信。因为这种对等方通信不必通过专门的服务器，所以该体系被称为对等方到对等方（简称为对等）。<br>P2P体系结构的最突出特性之一是它的<em>自扩展性（self-scalablity）</em>。在一个P2P文件共享应用中，尽管每个对等方都由请求文件产生负载，但每个对等方向其他对等方分发文件也为系统增加了服务能力。</p>
<h3 id="进程通信（processes-communicating）"><a href="#进程通信（processes-communicating）" class="headerlink" title="进程通信（processes communicating）"></a>进程通信（processes communicating）</h3><p>进程可以被认为是运行在端系统中的程序。当进程运行在相同的端系统上的时候，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。<br>不同端系统上的进程通过跨越计算机网络交换<strong>报文（message）</strong>，发送进程创建并向网络中发送报文，接收进程接收这些报文并可能负责回送报文。</p>
<ol>
<li>客户机和服务器进程<br>网络应用程序是由成对的进程组成，这些进程通过网络相互发送报文。对每对通信进程，我们通常将这两个进程之一标示为<strong>客户机（client）</strong>，而另一个进程标示为<strong>服务器（server）</strong>。<br><em>在给定的一对进程之间的通信会话中，发起通信（即在该会话开始时与其他进程联系）的进程被标示为<strong>客户机</strong>，在会话开始时等待联系的进程是<strong>服务器</strong>。</em></li>
<li>进程与计算机网络之间的接口<br>多数应用程序由通信进程组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为<strong>套接字（socket）</strong>的软件接口在网络上发送和接收报文。套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是在网络上建立网络应用程序的可编程接口，因此也将该套接字称为应用程序和网络之间的<strong>应用程序编程接口（Application Programming Interface, API)</strong>.<br>应用程序开发者可以控制套接字在<em>应用层</em>端的所有东西，但是对该套接字的<em>运输层</em>端几乎没有控制</li>
</ol>
<h3 id="进程寻址（Addressing-processes）"><a href="#进程寻址（Addressing-processes）" class="headerlink" title="进程寻址（Addressing processes）"></a>进程寻址（Addressing processes）</h3><p>为了识别接收进程，需要定义两种信息：</p>
<ol>
<li>该主机的名称或地址，<br>在因特网中，主机是用<strong>IP地址（IP address）</strong>进行标识。IP地址是用来<em>唯一</em>标识主机的32位比特数。</li>
<li>用来指定目的主机上接收进程的标示。<br>因为通常在一台主机能够运行许多网络应用程序，目的地<strong>端口号（port number）</strong>就是服务于识别运行在主机上的接收进程。已经给流行的应用程序分配了特定的端口号。例如，Web服务进程用的是80号端口</li>
</ol>
<h3 id="应用层协议（application-layer-protocol）"><a href="#应用层协议（application-layer-protocol）" class="headerlink" title="应用层协议（application-layer protocol）"></a>应用层协议（application-layer protocol）</h3><p>应用层协议定义了在不同端系统上的应用程序进程如何相互传递报文：</p>
<ul>
<li>交换的报文类型，如请求报文和响应报文。</li>
<li>各种报文类型的语法，如报文中的各个字段及其详细描述</li>
<li>字段的语义，即包含在字段中的信息的含义</li>
<li>进程何时、如何发送报文及对报文进行响应的规则<br>有些应用层协议是由RFC文档定义的，因此它们位于公共领域。例如，Web的应用层协议HTTP（超文本传输协议[RFC 2616]）就作为一个RFC供大家使用。<br>还有很多其他应用层协议是专用的，不能随意应用于公共领域。例如，很多现有的P2P文件共享系统使用的是专用应用层协议。<br>区分网络应用和应用层协议是很重要的。应用层协议只是网络应用中的一部分。</li>
</ul>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><p>应用程序服务要求进行分类：</p>
<ul>
<li>可靠数据传输<br>对于某些应用，必须确保由应用程序的一端发送的数据正确地、完全地交付给该应用程序的另一段。如果一个协议提供了这样的确保数据交付服务，就提供了<strong>可靠数据传输（reliable data transfer）</strong>。当一个运输层协议提供这种服务时，发送进程只要将其数据传递到套接字，就可以相信该数据将能无差错地到达接收进程。<br>当一个运输层协议不提供可靠数据传输时，由发送进程发送的数据可能不能到达接收进程。对于<strong>容忍丢失的应用（loss-tolerant application）</strong>来说这是可以接受的。</li>
<li>吞吐量<br>两个进程在一条网络路径上进行通信会话时，可用吞吐量就是发送进程能够向接收进程交付比特的速率。运输层协议能够以某种特定的速率提供确保的可用吞吐量。<br>如果运输层协议不能提供这种吞吐量，那么该应用程序或以较低速率（并且接收带宽也必须足以维持这种较低的编码速率）进行编码，或应当放弃发送。<br>具有吞吐量要求的应用程序称为<strong>带宽敏感的应用（bandwidth-sensitive application）</strong>，能够根据需要充分利用可供使用的吞吐量的应用程序称为<strong>弹性应用（elastic application）</strong>。<em>电子邮件、文件传输以及Web传输都属于弹性应用</em></li>
<li>定时<br>运输层协议也能提供定时保证。例如，可以设置发送方注入套接字中的每个比特到达接收方的套接字不迟于100ms。<br>这种服务对于交互式实时应用程序非常适用，例如，对于因特网电话、虚拟环境、电视会议和多方游戏。<br>在非实时的应用中，较低时延总要比较高时延好，但对端到端的时延没有严格的约束。</li>
<li>安全性<br>这种服务将对发送进程和接收进程保密，以防发送进程和接收进程以某种方式观察到数据。运输层协议也能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别<br><img src="/images/8/8a1.png" alt="部分网络技术的要求"></li>
</ul>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><p>因特网（更一般说是TCP/IP网络）上的应用使用了两个运输层协议：UDP和TCP。</p>
<ol>
<li>TCP服务</li>
</ol>
<ul>
<li>可靠数据传输服务（reliable transport）：进行通信的进程依靠TCP协议，无差错、按照适当顺序交付发送的数据。当应用程序的一端通过套接字传送一个字节流时，它能够依靠TCP协议将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</li>
<li>面向连接服务（connection-oriented）：使用TCP协议时，在应用层数据报文开始流动之前，其客户机程序和服务器程序之间相互交换运输层控制信息。这个所谓的握手过程提示客户机和服务器做好传输分组的准备。在握手阶段后，就在两个进程的套接字之间建立了一个<strong>TCP连接（TCP connection）</strong>。当应用程序结束报文发送时，必须拆除该连接。</li>
<li>拥塞控制机制（congestion transport）：当发送方和接收方之间的网络出现拥塞时，TCP协议的拥塞控制机制会抑制发送进程（客户机或服务器），它会试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。<br><em>TCP并不提供定时服务，确保最小可用吞吐量和加密机制</em><br><em>人们已经研制了TCP的加强版本，称为<strong>安全套接字层（Secure Socket Layer，SSL）</strong>。用SSL加强后的TCP不仅能够做传统TCP所能做的一切，而且还提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别，这种加强是在应用层上实现的</em></li>
</ul>
<ol>
<li>UPD服务<br>UDP是一种不提供不必要服务的轻量级运输层协议，它仅提供最小服务。<br>UDP协议提供的是不可靠数据传输服务。<br>UDP没有拥塞控制机制，所以发送端可以以任何速率向其下面的层（网络层）注入数据。因为实时应用通常可以忍受一定的数据丢失，同时有最低速率的要求，所以开发者有时在这种应用程序中会选择使用UDP协议，以避开TCP协议的拥塞控制机制和分组开销。</li>
</ol>
<p><img src="/images/8/8a2.png" alt="流行的因特网应用及其应用层协议和支撑的应用层协议"></p>
<h2 id="Web应用和HTTP协议"><a href="#Web应用和HTTP协议" class="headerlink" title="Web应用和HTTP协议"></a>Web应用和HTTP协议</h2><p><strong>Web页面（Web page，也叫文档）</strong>是由<strong>对象（object）</strong>组成的。<br>对象简单来说就是文件，如HTLML文件、JPEG图形文件、Java小程序或视频片段文件，这些文件可以通过一个URL地址寻址。<br>多数Web页面包含一个<strong>基本HTML文件（base HTML file）</strong>以及几个引用对象。<br>例如，如果一个Web页面包含HTML文本和5个JPEG图形文件，那么这个Web页面有6个对象：一个基本HTML文件加5个图形。在基本HTML文件中通过对象的URL地址对对象进行引用。每个URL地址由两部分组成：存放对象的服务器主机和对象的路径名<br><img src="/images/8/8a3.png" alt="URL地址例子"><br><strong>Web浏览器（Web browser，如Internet Explore）</strong>实现了HTTP的客户机端。Web服务器（Web server）用于储存Web对象，每个对象由URL寻址。Web服务器实现了HTTP的服务器端。</p>
<h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>Web的应用层协议是<strong>超文本传输协议（HyperText Transfer Protocol, HTTP)</strong>。<br>HTTP协议由两部分程序实现：一个客户机程序和一个服务器程序，他们运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的格式以及客户机和服务器是如何进行报文交换的。<br>HTTP使用TCP作为它的支撑运输层协议<br>服务器向客户机发送被请求的文件时，并不储存任何关于该客户机的状态信息。因为一个HTTP服务器并不保存关于客户机的任何信息，所以我们说HTTP是一个<strong>无状态协议（stateless protocol）</strong>。<br>Web服务器总是打开的，具有一个固定的IP地址，它服务于数以百万记的不同浏览器。</p>
<h3 id="非持久连接和持久连接"><a href="#非持久连接和持久连接" class="headerlink" title="非持久连接和持久连接"></a>非持久连接和持久连接</h3><ul>
<li>非持久连接<br><img src="/images/8/8a4.png" alt="非持久连接例子"><br>每个TCP连接在服务器返回对象后关闭，即该连接并不为其他的对象而持续下来。<br>如果客户机获得多个对象需要建立多个连接</li>
</ul>
<p><strong>往返时间（Round-Trip Time，RTT）</strong>：一个小分组从客户机到服务器再回到客户机所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延<br><img src="/images/8/8a5.png" alt="请求并接收一个HTML文件所需要的时间"><br>如图所示，浏览器在浏览器和Web服务器之间发起一个TCP连接，其中涉及一个“三次握手”过程，即客户机向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应，最后客户机向服务器返回确认。完成了三次握手的前两个部分后，客户机将三次握手的第三个部分（确认）与一个HTTP请求报文结合起来发送到该TCP连接。一旦该请求报文到达服务器，服务器向该TCP连接发送HTML文件。<br>粗略地讲，总的响应时间就是两个RTT加上服务器传输HTML文件的时间。</p>
<p>非持久连接的缺点：必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户机和服务器都要分配TCP的缓冲区和变量，这给服务器带来了严重的负担。每一个对象的传输时延为两个RTT，其中一个用于建立TCP，另一个RTT用于请求和接收一个对象。</p>
<ol>
<li>持久连接<br>在持久连接的情况下，服务器在发送响应后应保持该TCP连接打开。在相同的客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。对这些对象的请求可一个接一个地发出，而不必等待未决请求的回答（流水线）。<em>一般来说，如果一个连接经过一定时间间隔仍未被使用，HTTP服务器就关闭连接</em>。</li>
</ol>
<h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p>HTTP规约[RFC 2616]包含了对HTTP报文格式的定义。HTTP报文有两种：请求报文和响应报文</p>
<ul>
<li>HTTP请求报文<br><img src="/images/8/8a6.png" alt="HTTP请求报文"><br>HTTP请求报文第一行叫做<strong>请求行（request line）</strong>，请求行有三个字段：方法字段、URL字段和HTTP协议版本字段。方法字段可以取值GET、POST、HEAD、PUT和DELETE。绝大部分的HTTP请求报文使用GET方法。在URL字段填写该对象的URL地址。<br>第一行后继的行叫做<strong>首部行（header line）</strong>。</li>
</ul>
<p><img src="/images/8/8a7.png" alt="HTTP请求报文的通用格式"><br>上图展示的是请求报文的通用格式。<br>在首部行后有一个“实体主体”（entity body）。使用GET方法时实体主体为空，而使用POST方法时才使用，HTTP客户机常常在用户提交表单时使用POST方法。例如，用户向搜索引擎提供搜索关键词。在使用POST方法的报文中，用户仍可以向服务器申请一个Web页面，但Web页面的特定内容依赖于用户在表单字段中输入的内容。<br>HEAD方法类似于GET方法。应用程序开发者常用HEAD方法进行故障跟踪。<br>PUT方法常与Web发行工具联合使用，用户利用它来将对象上传到指定的Web服务器上指定的路径。PUT方法也被应用程序用来向Web服务器上传对象。<br>利用DELETE方法，用户或者应用程序可以删除Web服务器上的对象。</p>
<ul>
<li>HTTP响应报文<br>响应报文分成三个部分：一个状态初始行（status line）、6个首部行（header line），然后是<strong>实体主体（entity body）</strong>。<br>状态行有三个字段：协议版本、状态码和相应服务信息。</li>
</ul>
<h3 id="用户与服务器的交互：cookie"><a href="#用户与服务器的交互：cookie" class="headerlink" title="用户与服务器的交互：cookie"></a>用户与服务器的交互：cookie</h3><p>HTTP服务器是无状态的，若一个Web站点通常希望能够识别用户，HTTP使用cookie来满足这一需求<br>cookie技术有4个组成部分：</p>
<ol>
<li>在HTTP响应报文中有一个cookie首部行</li>
<li>在HTTP请求报文中有一个cookie首部行</li>
<li>在用户端系统中保留一个cookie文件，由用户的浏览器管理</li>
<li>在Web站点有一个后端数据库。<br><img src="/images/8/8a8.png" alt="用cookie保持用户状态"></li>
</ol>
<h3 id="Web缓存器（代理服务器）"><a href="#Web缓存器（代理服务器）" class="headerlink" title="Web缓存器（代理服务器）"></a>Web缓存器（代理服务器）</h3><p><strong>Web缓存器（Web cache）</strong>也叫<strong>代理服务器（proxy server）</strong>，它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘储存空间，并在该储存空间中保存所有最近请求过的对象的拷贝。可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。1）如果Web缓存器检查本地是否储存了该对象拷贝。如果有，Web缓存器就用HTTP响应报文向客户机浏览器返回该对象。2）如果Web缓存器没有该对象，他就与初始服务器打开一个TCP连接。Web缓存器则在TCP连接上发送则在TCP连接上发送获取该对象的HTTP请求。在收到请求后，初始服务器向Web缓存器发送具有该对象的HTTP响应。<br><img src="/images/8/8a9.png" alt="客户机通过Web缓存器请求对象"><br>注意到Web缓存器既是服务器又是客户机。<br>一般而言，Web缓存器由ISP购买并安装。<br>在因特网上部署Web缓存器的原因：</p>
<ol>
<li>Web缓存器可以大大减少对客户机请求的响应时间，特别是当客户机在于初始服务器之间的瓶颈带宽远低于客户机与Web缓存器之间的瓶颈带宽时更是如此。</li>
<li>Web缓存器可以大大减少一个机构内部网与因特网接入链路上的通信量。通过减少通信量，该机构就不必急于增加带宽，因此会降低费用。</li>
<li>Web缓存器能从整体上大大降低因特网上的Web流量，从而改善了所有应用的性能。</li>
</ol>
<p>对于Web缓存器优点的例子可以通过看书来进一步理解，书中已足够详细。</p>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>HTTP协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是<strong>条件GET（conditional GET）</strong>方法<br>如果1）请求报文使用GET方法；2）请求报文中包含一个If-modified-since：首部行。那么这个HTTP请求报文就是一个条件GET请求报文。<br>在一段时间后请求一个已被储存在Web缓存器中的对象时，该缓存器通过发送一个条件GET给服务器，执行最近检查，首部行中包括If-modified-since：储存对象时对象的最后修改时间。接下来，Web 服务器向该缓存器发送一个响应报文，该报文状态行中状态码和响应状态信息的值为304 Not Modified时，它告诉缓存器可以使用该对象，否则向Web缓存器发送更改后的对象。</p>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮件系统的3个主要组成部分：<strong>用户代理（user agent）</strong>、<strong>邮件服务器（mail server）</strong>和<strong>简单邮件传输协议（Simple Mail Transfer Protocol, SMTP)</strong>。</p>
<ul>
<li>用户代理允许用户阅读、回复、转发、保存和撰写报文</li>
<li>邮件服务器组成了电子邮件体系的核心。每个接收方在其中的某个服务器上有一个<strong>邮箱（mailbox）</strong>，邮箱管理和维护发送给接收方的报文。如果发送方的服务器不能将邮件交付到接收方的服务器时，发送方的邮件服务器在一个<strong>报文队列（message queue）</strong>中保持该报文并在以后尝试再次发送。</li>
<li>SMTP</li>
</ul>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件，端口号25。<br>SMTP一般不使用中间邮件服务器发送邮件。如果接收方的邮件服务器没有开机，该报文会保留在发送方的邮件服务器上并在稍后进行新的尝试，这意味着邮件并不在中间的某个服务器上存留。<br>使用SMTP将一个报文从发送邮件服务器传送到接收邮件服务器有以下步骤：</p>
<ol>
<li>如果服务器没有开机，客户机会在稍后继续尝试连接。一旦连接建立，服务器和客户机就执行一些应用层的握手。在SMTP握手的阶段，SMTP客户机指明发送方的邮件地址（产生报文的那个人）和接收方的邮件地址。</li>
<li>一旦该SMTP客户机和服务器彼此介绍之后，客户机就发送该报文。SMTP可以利用TCP提供的可靠数据传输无差错的将邮件投递到接收服务器。</li>
<li><p>该客户机如果有另外的报文要发送到该服务器，就在该相同的TCP连接上重复这种处理，否则，它指示TCP关闭连接。</p>
<p>STMP客户机（C）和STMP服务器（S）之间交换脚本使用的是ASCII码<br>SMTP用的是持久连接：如果发送邮件服务器有几个报文发往同一个接收邮件服务器，它可以通过同一个TCP连接发送所有的这些报文。</p>
<p>SMTP限制所有邮件报文的主体部分（不只是其首部）只能采用简单的7位ASCII码表示。</p>
</li>
</ol>
<h3 id="SMTP和HTTP进行对比"><a href="#SMTP和HTTP进行对比" class="headerlink" title="SMTP和HTTP进行对比"></a>SMTP和HTTP进行对比</h3><ol>
<li>当进行文件传输时，HTTP和SMTP都是用持久连接</li>
<li>它们在建立TCP连接的时候都有握手的过程？</li>
<li>HTTP主要是一个<strong>拉协议（pull protocol）</strong>，即人们可以在方便的时候装载Web服务器上的信息，也就是说，用户使用HTTP从该服务器拉取信息。<br>SMTP基本上是一个<strong>推协议（push protocol）</strong>，即发送邮件服务器把文件推向接收邮件服务器</li>
<li>SMTP要求每个报文（包括它们的主体）都使用7为ASCII码格式。HTTP数据则没有这个限制</li>
<li><p>HTTP把每个对象封装到它自己的HTTP响应报文中，而因特网电子邮件则把所有报文对象放在一个报文之中。</p>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>首部行储存环境信息在报文主体的前面，这些行由RFC822定义，首部行和该报文主体用空行（即回车换行）进行分隔。RFC822定义了邮件首部行及其语义解释的精确格式。<br>某些关键词是必须的，有些则是可选的。<br>这些首部行不同于SMTP的握手协议。<br>在报文首部之后，紧接着是一个空白行，然后是以ACSII格式表示的报文主体。</p>
</li>
</ol>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>有多个流行的邮件访问协议来使接收方的用户代理可从邮件服务器中取出邮件：<strong>第三版的邮局协议（Post Office Protocol-Version 3）</strong>、<strong>因特网邮件访问协议（Internet Mail Access Protocol, IMAP)</strong>以及HTTP。<br><img src="/images/8/8a10.png" alt="电子邮件协议及其通信实体"></p>
<ol>
<li>POP3<br>POP3是一个非常简单的邮件访问协议，由RFC1939进行了定义。<br>随着TCP连接的创建，POP3按照几个阶段进行工作：</li>
</ol>
<ul>
<li>特许（authorization）阶段<br>用户发送（以明文形式）用户名和口令以鉴别用户。<br>特许阶段有两个主要的命令：use<user name>和pass<password></password></user></li>
<li>事务处理阶段<br>用户代理取回报文，在这个阶段，用户代理还能进行以下操作：对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。<br>使用POP3的用户代理通常由用户配置为“下载并删除”或者“下载并保留”方式。<br>在特许阶段以后，用户代理仅使用四个命令：list、retr、dele和quit</li>
<li>更新阶段<br>它出现在P客户机发出了quit命令之后，目的是结束该POP3会话；这时，邮件服务器删除那些被标记为删除的报文。</li>
</ul>
<p>在POP3中，用户代理发出一些命令，服务器对每个命令做出回答。回答可能是两种：+OK（有时后面还跟有服务器到客户机的数据），服务器用它来指示前面的命令是正常的；-ERR，服务器用它来指示前面的命令出现了差错。</p>
<ol>
<li>IMAP<br>POP3没有给用户提供任何创建远程文件夹以及为报文指派文件夹的方法。<br>IMAP服务器把每个报文与一个文件夹联系起来，IMAP服务器把所有报文都储存在服务器中。<br>IMAP服务器维护了IMAP会话的用户状态信息，例如，文件夹的名字以及哪个报文与哪个文件夹相关联。<br>IMAP的另一个重要特性是它具有允许用户代理获取报文组件的命令</li>
</ol>
<p>1】定时和吞吐量的区别<br>2】对端到端的时延没有严格的约束<br>3】为什么说UPD没有提供吞吐量的保证<br>4】持久连接的缺点<br>5】为什么说报文是用普通的ASCII码书写的<br>6】用表单生成的请求报文不需要使用POST方法<br>7】响应报文主体包含了所请求对象的本身<br>8】how to keep state<br>9】Internet dense with caches: enables “poor” content providers to effectively deliver content (so too does P2P file sharing)<br>10】POP3 is stateless across sessions<br>11】IMAP和POP3的区别</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/05/CSE201W1-Storage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/05/CSE201W1-Storage/" class="post-title-link" itemprop="url">CSE203W1_Storage</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-05 16:36:34" itemprop="dateCreated datePublished" datetime="2019-09-05T16:36:34+08:00">2019-09-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-15 15:08:22" itemprop="dateModified" datetime="2019-09-15T15:08:22+08:00">2019-09-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="数据存储和数据存取"><a href="#数据存储和数据存取" class="headerlink" title="数据存储和数据存取"></a>数据存储和数据存取</h1><h2 id="物理存储介质概述"><a href="#物理存储介质概述" class="headerlink" title="物理存储介质概述"></a>物理存储介质概述</h2><ol>
<li><p><strong>高速缓存器(cache)</strong> 高速缓存器是最快最昂贵的储存介质。高速缓存器一般很小，由计算机系统硬件来管理它的使用。</p>
</li>
<li><p><strong>主存储器(main memory)</strong> 主存储器是用于存放可处理的数据的储存介质。通用机器指令在主储存器上执行。如果发生电源故障或者系统崩溃，主存储器中的内容通常会丢失。</p>
</li>
<li><p><strong>快闪存储器(flash memory)</strong> 快闪存储器不同于主存储器的地方是在电源关闭（或故障）时数据可以保存下来。</p>
</li>
<li><p><strong>磁盘存储器(magnetic-disk storage)</strong> 用于长期联机数据存储的主要介质是磁盘。通常整个数据库都存储在磁盘上，为了能够访问数据，系统必须将数据从磁盘移动到主存储器。在完成指定的操作后，修改过的数据必须写回磁盘。磁盘存储器不会因为系统故障和系统崩溃丢失数据。磁盘存储设备本身有时有可能会发生故障，导致数据的损坏，但是发生磁盘故障的概率比发生系统崩溃的概率小很多。</p>
</li>
<li><p><strong>光学存储器(optical storage)</strong><br>光学存储器最流行的形式是光盘(Compact Disk, CD)，它可以容纳大约700MB的数据，播放约80分钟。<br>数字视频光盘(Digital Video Disk, DVD)的每一盘面可以容纳4.7GB或8.5GB的数据。<br>可以用数字万能光盘(digital versatile disk)代替数字视频光盘(digital video disk)作为DVD的全称，因为DVD可以存储任何数字数据而不是仅仅视频数据。<br>数据通过光学的方法储存到光盘上，并通过激光器读取。</p>
</li>
<li><p><strong>磁带存储器(tape storage)</strong> 磁带存储器主要用于备份数据和归档数据。</p>
</li>
</ol>
<p><img src="/images/7/7a1.png" alt="储存设备层次结构"><br>根据不同储存介质的速度和成本，可以把它们按层次结构组织起来。层次越高，这种存储介质的成本就越贵，但是速度就越快。当我们沿着层次结构向下，储存介质每比特的成本下降，但是访问时间会增加。</p>
<h2 id="磁盘和闪存"><a href="#磁盘和闪存" class="headerlink" title="磁盘和闪存"></a>磁盘和闪存</h2><h3 id="磁盘的物理特性"><a href="#磁盘的物理特性" class="headerlink" title="磁盘的物理特性"></a>磁盘的物理特性</h3><p><img src="/images/7/7a2.png" alt="磁盘移动头机制"><br>磁盘上的每一个<strong>盘片(platter)</strong>是扁平的圆盘，它的两个表面都覆盖着磁性物质，信息就记录在表面上，盘片由硬金属或玻璃制成。<br>盘片的表面从逻辑上划分为<strong>磁道(track)</strong>，磁道又划分为<strong>扇区（sector)</strong>。<em>扇区是从磁盘读出和写入信息的最小单位</em>。<br>通过反转磁性物质化的方向，<strong>读写头（read-write head）</strong>将信息磁化存储到扇区中。磁盘的每个盘片的每一面都有一个读写头，读写头通过在盘片上移动来访问不同的磁道。一张磁盘通常包括很多个盘片，所有磁道的读写头安装在一个称为<strong>磁盘臂（disk arm）</strong>的单独装置上，并且一起移动。安装在转轴上的所有磁盘盘片和安装在磁盘臂上的所有读写头统称为<strong>磁头-磁盘装置（head-disk assembly）</strong><br>因为所有盘片上读写头一起移动，所以当某一盘片的读写头在第$i$条磁道上时，所有其他盘片的读写头也都在各自盘片的第$i$条磁道上。因此，所有盘片的第$i$条磁道和在一起称为第$i$个<strong>柱面（cylinder）</strong>。<br><strong>磁盘控制器（disk controller）</strong>作为计算机系统和实际的磁盘驱动器硬件之间的接口。</p>
<h3 id="磁盘性能的度量"><a href="#磁盘性能的度量" class="headerlink" title="磁盘性能的度量"></a>磁盘性能的度量</h3><p>磁盘质量的主要度量指标是容量、访问时间、数据传输率和可靠性<br><strong>访问时间（access time）</strong>是从发出读写请求到数据开始传输之前的时间。<br><em>Access time = Seek time + Rotational latency + (Transfer time)</em></p>
<ol>
<li><p><strong>寻道时间（Seek time）</strong>：为了访问（即读或写）磁盘上指定扇区的数据，磁盘臂首先必须移动，以定位到正确的磁道，磁盘臂重定位的时间称为<strong>寻道时间</strong>。从最里面的磁道到最外面的磁道是最糟糕的情况。<strong>平均寻道时间（Average seek time）</strong>是寻道的平均值，如果考虑读写头开始移动和结束移动所花费的时间，平均寻道时间大约是最长寻道时间的1/2.</p>
</li>
<li><p><strong>旋转等待时间（rotational latency time）</strong>：一旦读写头到达了所需的磁道，等待访问的扇区出现在读写头下所花费的时间称为<strong>旋转等待时间</strong>。平均情况下，磁盘需要旋转半周才能使所要访问的扇区开始处于读写头的下方。因此磁盘的<strong>平均旋转等待时间</strong>是磁盘旋转一周时间的1/2。</p>
</li>
<li><p><strong>数据传输率（data-transfer rate）</strong>是从磁盘获得数据或者向磁盘储存数据的速率。在大部分情况下，数据传输率远小于寻道时间和旋转等待时间。</p>
</li>
</ol>
<h3 id="磁盘块访问的优化"><a href="#磁盘块访问的优化" class="headerlink" title="磁盘块访问的优化"></a>磁盘块访问的优化</h3><p>磁盘I/O请求是由文件系统和大多数操作系统具有的虚拟内存管理器产生的。每个请求指定了要访问的磁盘地址，这个地址是以<em>块号</em>的形式提供的。一个<strong>块（block）</strong>是一个逻辑单元，它包含固定数目的连续扇区。块大小在512字节到几KB之间。数据在磁盘和主储存器之间以块为单位传输。<br><em>Smaller blocks: more transfers from disk</em><br><em>Larger blocks: more space wasted due to partially filled blocks</em></p>
<p><strong>磁盘臂调度（disk-arm-scheduling）算法</strong>试图把对磁道的访问按照能增加可以处理的访问数量的方式排序<br><strong>电梯算法（elevator algorithm）</strong>是最常使用的算法</p>
<h2 id="文件和记录的组织"><a href="#文件和记录的组织" class="headerlink" title="文件和记录的组织"></a>文件和记录的组织</h2><h3 id="文件组织（file-organization）"><a href="#文件组织（file-organization）" class="headerlink" title="文件组织（file organization）"></a>文件组织（file organization）</h3><p>为了减少块访问时间，我们可以按照与预期数据访问方式最接近的方式来组织磁盘上的块。例如，如果我们预计一个文件将顺序地访问，那么理想情况下我们应该使文件的所有块储存在连续的相邻柱面上。<br>一个数据库被映射到多个不同的文件，一个<strong>文件（file）</strong>在逻辑上组织成为<strong>记录（record）</strong>的一个<strong>序列（sequence）</strong>。这些记录映射到<strong>磁盘块（fields）</strong>。<br>每个文件分为定长的储存单元，称为<strong>块</strong>，块是储存分配和数据传输的基本单元。<br>我们需要要求每条记录包含在单个块中，换句话说，没有记录是部分包含在一个块中，部分包含在另一个块中。这个限制简化并加速数据项访问。<br>在关系数据库中，不同关系的远组通常具有不同的大小。把数据库映射到文件的一种方法是使用多个文件，在任意一个文件中只储存一个固定长度的记录。另一种选择是构建自己的文件，使之能够容纳多钟长度的记录。定长记录比变长记录文件更容易实现。</p>
<ul>
<li><strong>定长记录（fixed-length records）</strong><br>存在的问题：</li>
</ul>
<ol>
<li>除非块的大小恰好是记录的倍数，否则部分记录会跨过快的边界，即一条记录的一部分储存在一个块里，另一部分储存在另一个块里，于是读写这样的一条记录需要两次块访问。<em>分配尽可能多的记录在一个块里</em></li>
<li>从这个结构中删除一条记录十分困难。删除的记录所占据的空间必须由文件中的其他记录来填充，或者我们必须用一种方法标记删除的记录使得它可以被忽略。*移动记录以删除记录所释放空间的做法并不理想，因为这样做需要额外的块访问操作。<br>解决方案：</li>
<li>在文件的开始处，我们分配一定数量的字节作为<strong>文件头（file header</strong>。文件头将包含有关文件的各种信息。到目前为止，我们需要在文件头中储存的只有内容被删除的第一个记录的地址。我们用这第一个记录来储存第二个可用记录的地址。我们可以直观的把这些储存的地址看作指针，因为他们指向一个记录的位置。</li>
<li>被删除的记录形成了一条<strong>链表</strong>，经常称为<strong>空闲链表（free list）</strong></li>
<li>在插入一条新记录时，我们使用文件头所指向的记录，并改变文件头的指针以指向下一个可用记录。如果没有可用的空间，我们就把这条新纪录添加到文件末尾🔚。<br><em>对于定长记录文件的插入和删除是容易实现的，因为被删除的记录留出的可用空间恰好是插入记录所需要的空间。如果我们允许文件中包含不同长度的记录，这样的匹配将不再成立。插入的记录可能无法放入一条被删除记录所释放的空间中，或者只能占用这个空间的一部分。</em></li>
</ol>
<ul>
<li><strong>变长记录（variable-length records）</strong><br>一条有变长度属性的记录表示通常具有两个部分：初识部分是定长属性，接下来是变长属性。<br>定长属性，如数字值、日期或定长字符串，分配储存它们的值所需的字节数。<br>变长属性，在记录的初始部分中表示为一个对（偏移量，长度）值，其中偏移量表示在记录中该属性的数据开始的位置，长度表示变长属性的字节长度。在记录的初识定长部分之后，这些属性的值是连续储存的。<br><em>因此，无论是定长还是变长，记录初始部分储存有关每个属性的固定长度的信息。</em></li>
</ul>
<p>一般用<strong>分槽的页结构（slotted-page structure）</strong>在块中组织记录，来处理在块中储存变长记录的问题。<br><img src="/images/7/7a3.png" alt="分槽的页结构"><br>每个块的开始有一个块头，其中包含以下信息：</p>
<ol>
<li>块头中记录条目的个数</li>
<li>块中空闲空间的末尾处</li>
<li>一个由包含记录位置和大小的记录条目组成的数组</li>
</ol>
<p>实际记录从块的<strong>尾部</strong>开始<em>连续</em>排列。块中空闲空间是连续的，在块头数组的最后一个条目和第一条记录之间。<br>如果插入一条记录，在空闲空间的尾部给这条记录分配空间，并且将包含这条记录大小和位置的条目添加到块头中。<br>如果一条记录被删除，它所占用的空间被释放，并且它的条目被设置成被删除状态（例如这条记录的大小被设置成-1）。此外，块中在被删除记录之前的记录将被移动，使得由删除而产生的空闲空间被重用，并且所有的空闲空间仍然存在于块头数组的最后一个条目和第一条记录之间。块头中的空闲空间末尾指针也要做适当修改。只要块中有空间，使用类似的技术可以使记录增长或缩短。<br><em>大对象常常被B+树文件组织</em>。</p>
<h2 id="文件中记录的组织"><a href="#文件中记录的组织" class="headerlink" title="文件中记录的组织"></a>文件中记录的组织</h2><ul>
<li><strong>堆文件组织（heap file organization）</strong>。一条记录可以放在文件中的任何地方，只要那个地方有空间存放这条记录。记录是没有顺序的。通常每个关系使用一个单独的文件。</li>
<li><strong>顺序文件组织（sequential file organization）</strong>。记录根据其“搜索码”的值顺序储存。</li>
<li><strong>散列文件组织（hashing file organization）</strong>。在每条记录的每个属性上计算一个散列函数。散列函数的结果确定了记录该放到文件的哪个块中。<br>通常，每个关系的记录用一个单独的文件储存。但是在<strong>多表聚簇文件组织（multitable clustering file organization）</strong>中，几个不同关系的记录储存在同一个文件中。而且，不同关系的相关记录储存在相同的块中，于是一个I/O操作可以从所有关系中取到相关的记录。</li>
</ul>
<p>各种方式的优劣<br><img src="/images/7/7a4.png" alt="各种文件组织的优劣"></p>
<h3 id="顺序文件组织"><a href="#顺序文件组织" class="headerlink" title="顺序文件组织"></a>顺序文件组织</h3><p><strong>顺序文件（sequential file）</strong>是为了高效处理按某个搜索码的顺序排序的记录而设计的。为了快速地按照搜索码的顺序获取记录，我们通过指针把记录链接起来，每条记录的指针指向按搜索码顺序排列的下一条记录。此外，为了减少顺序文件处理中的快访问数，我们物理上按搜索码顺序或者尽可能地接近按搜索码顺序储存记录。<br>顺序文件组织形式适合于记录按排序的顺序读取，但在插入和删除记录时维护记录的物理顺序是十分困难的。<br>我们使用指针链表来管理删除。<br>插入操作则应用以下规则：</p>
<ul>
<li>如果这条记录所在块中有一条空闲记录（删除后留下来的空间），就插到这里。</li>
<li>如果没有空闲空间，则新纪录要插入到一个<strong>溢出块（overflow block）</strong>中。<br><em>无论哪种情况，都要调整指针，使其能按搜索顺序把记录连接在一起。</em></li>
</ul>
<h3 id="多表聚簇文件组织"><a href="#多表聚簇文件组织" class="headerlink" title="多表聚簇文件组织"></a>多表聚簇文件组织</h3><p><img src="/images/7/7a5.png" alt="多表聚簇文件组织"><br>多表聚簇文件组织是一种在每一块中储存两个或更多关系的相关记录的文件结构。<br>这样的文件组织允许我们使用一次块的读操作来<strong>满足</strong>连接条件的记录。<br>但对于普通单表关系查询则会变慢<br>产生变化长度的记录<br>可以添加指针去用一种特殊的关系连接记录</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/02/CSE205W1_Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/02/CSE205W1_Introduction/" class="post-title-link" itemprop="url">CSE205W1_Introduction to the Internet</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-02 09:59:43" itemprop="dateCreated datePublished" datetime="2019-09-02T09:59:43+08:00">2019-09-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-15 15:07:34" itemprop="dateModified" datetime="2019-09-15T15:07:34+08:00">2019-09-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h2><p>在电路交换网络中，沿着端系统通信路径，为端系统之间通信所提供的资源（缓存、链路传输速率）在通信会话期间会被预留。<br>在分组交换网络中，这些资源则不会被预留，会话的报文按需使用这些资源，这将导致可能不得不等待（即排队）接入通信线路。<br>并非所有的电信网络都能够被明确地归类为电路交换网络或分组交换网络。</p>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="/images/6a1.png" alt="由4台交换机和4条链路组成的简单电路交换网络"><br>在上图中，每台主机（例如PC和工作站）都与一台交换机直接相连。当两台主机要通信时，该网络在两台主机之间创建一条专用的端到端连接（end-to-end connection）。因此，主机A为了向主机B发送报文，该网络必须在两条链路之一上先预留一条电路。假设每条链路具有n条电路，每条链路由端到端连接使用，该连接在连接期间获得该链路带宽的1/n部分。</p>
<h3 id="电路交换网络中的多路复用"><a href="#电路交换网络中的多路复用" class="headerlink" title="电路交换网络中的多路复用"></a>电路交换网络中的多路复用</h3><ul>
<li>链路中的电路可通过频分多路复用(Frequency-Division Multiplexing, FDM)实现。<br>对于FDM，链路的频谱由跨越链路创建的所有连接所共享。特别是，该链路在连接期间为每条连接专用一个频段。在电话网络中，这个频段通常具有4kHz（即每秒4000赫兹或4000周）。该频段的宽度被称为带宽(bandwidth)。</li>
<li>也可通过时分多路复用(Time-Division Multiplexing, TDM)实现。对于一条TDM链路，时间被划分为固定区间的帧，并且每帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，该网络在每个帧中为该连接指定一个时隙，在每个帧中具有4个时隙。一条电路的传输速率等于一个时隙中的比特数乘以该帧的速率。例如，如果链路每秒传输8000个帧，每个帧由8个比特组成，则一条电路的传输速率是64kbps。<br><img src="/images/6a2.png" alt="FDM和TDM"></li>
</ul>
<p>TDM相较于FDM优点为，当FDM中有频段未被使用时，会相应影响传输的速率。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>各种应用程序在完成其任务时要交换<strong>报文</strong>(message)。报文能够包含协议设计者需要的任何东西。<br>报文可以执行一种控制功能（握手例子中的“你好”报文，或能够包含数据（电子邮件数据、JPEG图像或MP3音频文件）。<br>在现代计算机网络中，源主机将长报文划分为较小的数据块，并称之为<strong>分组</strong>(packet)。在源和目的地之间，这些分组中的每个都通过通信链路和分组交换机(packet switch)传送。<em>交换机主要有两类：路由器和链路层交换机</em>。分组以该链路的最大传输速率在通信链路上传输。<br>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>(store-and-forward transmission)机制：在交换机能够开始向输出链路传输该分组的一个比特之前，必须接收到整个分组。</p>
<h3 id="分组交换与电路交换对比：统计多路复用"><a href="#分组交换与电路交换对比：统计多路复用" class="headerlink" title="分组交换与电路交换对比：统计多路复用"></a>分组交换与电路交换对比：统计多路复用</h3><p>分组交换总是具有与电路交换相同的性能，<em>并且用户数量是所支持的数量的3倍多也是如此</em>。<br>电路交换不考虑要求而预先分配传输链路的使用，这使得已分配但不需要的链路时间未被利用。另一方面，分组交换使用按需的方式分配链路。链路的传输能力将只在所有的其分组要在链路上传输的用户中，逐组地被共享。这样的按需共享资源有时被称为资源的<strong>统计多路复用</strong>(statistical multiplexing)。</p>
<h2 id="ISP和因特网主干"><a href="#ISP和因特网主干" class="headerlink" title="ISP和因特网主干"></a>ISP和因特网主干</h2><p>在公共因特网中，坐落在因特网边缘的接入网络通过分层的ISP层次结构与因特网的其他部分相连  </p>
<h2 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h2><h3 id="分组交换网中的时延概述"><a href="#分组交换网中的时延概述" class="headerlink" title="分组交换网中的时延概述"></a>分组交换网中的时延概述</h3><p>时延的类型</p>
<ol>
<li>节点处理时延(nodal processing delay)<br>检查分组首部和决定将该分组导向何处所需要的时间是<strong>处理时延</strong>的一部分，处理时延也包括其他因素。在这种节点处理之后，路由器将该分组引向通往路由器B之前的队列。</li>
<li>排队时延(queuing delay)<br>在队列中，当分组在链路上等待传输时，它经受<strong>排队时延</strong>。<br>一个特定分组的排队时延将取决于先期到达的、正在排队等待向链路传输的分组的数量。如果该队列是空的，并且当前没有其他分组在传输，则该分组的排队时延是0。另一方面，如果流量很大，并且许多其他分组也在等待传输，该排队时延将很大。</li>
<li>传输时延(transmission delay)<br>假定分组以先到先服务方式传输，仅当所有已经到达的分组被传输后，才能传输我们的分组。<br>用$L$比特表示分组的长度，用$R$bps表示从路由器A到路由器B的链路传输速率传输时延（又称为储存转发时延）是$L/R$。<br>假定两台主机中间有$Q$条链路，它必须储存转发$Q$次，因此总时延为$QL/R$。</li>
<li>传播时延(proagation delay)<br>一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间是<strong>传播时延</strong>，该传播速率取决于该链路的物理媒体（即光纤、双绞铜线等）。<br>如果$d$是路由器A和路由器B之间的距离，$s$是传播速率，传播时延等于两台路由器之间的距离除以传播速率，即传播时延是$d/s$。<br>若传输时延大于传播时延，则会出现一个分组中的前几个比特到达了一台路由器，而该分组中还有余下的比特仍在前面的路由器中等待传输。</li>
</ol>
<p>如果令<script type="math/tex">d_{proc}，d_{queue}，d_{trans}，d_{prop}</script>分别表示处理时延、排队时延、传输试验和传播时延，则节点的总延时由下式给定：</p>
<script type="math/tex; mode=display">
d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}</script><h3 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h3><p>与其他三项时延不同的是，排队时延对不同的分组是不同的。例如，如果10个分组同时到达空队列，传输的第一个分组没有排队时延，而传输的最后一个分组将经受相对大的排队时延（这时它要等待其他九个分组被传输）。<br>$a$表示分组到达队列的平均速率（$a$的单位是每秒分组，即pkt/s），$R$是传输速率，即比特从队列中推出的速率（以bps为单位），假定所有分组都是由$L$比特组成的，则比特到达队列的平均速率是$La$bps。最后，假定该队列非常大，因此它基本能容纳无限数量的比特，比率$La/R$被称为<strong>流量强度(traffic intensity)</strong>。</p>
<ol>
<li>如果$La/R &gt; 1$，则比特到达队列的平均速率超过从该队列传输出去的速率。在这种情况下，队列的增加将趋于无界，并且排队时延将趋于无限大，因此，<strong>设计系统时流量强度不能大于1</strong></li>
<li>考虑$La/R &lt;= 1$时</li>
</ol>
<ul>
<li>如果分组周期性到达，每个分组将到达一个空队列中，因此不会有排队时延。</li>
<li>如果分组以突发形式到达而不是周期性到达，则有可能有很大的平均排队时延。<br><img src="/images/6a3.png" alt="平均排队时延和流量强度的关系"></li>
</ul>
<h3 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h3><p>排在一条链路前的队列只有有限的容量，所以流量强度接近于1时排队时延也不会趋向于无穷大，相反，到达的分组将会发现一个满的队列。由于没有地方存储这个分组，路由器将<strong>丢弃(drop)</strong>该分组，即该分组将会<strong>丢失(lost)</strong>。<br>节点的性能常常不仅要根据时延来度量，而且要根据分组丢失的概率来度量。</p>
<h3 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h3><p>为了定义吞吐量，考虑从主机A到主机B通过计算机网络传送一个大文件。</p>
<ul>
<li>瞬时吞吐量(instantaneous throughput)是主机B接收到该文件的速率（以bps计）。</li>
<li>平均吞吐量(average throughput)：若主机B接收到所有$F$比特用了$T$秒，则文件传送的<strong>平均吞吐量</strong>是$f/t$bps。<br>考虑计算机网络中的几个关于吞吐量的例子：<br><img src="/images/6a4.png" alt="从服务器传送一个文件到客户机的吞吐量"></li>
</ul>
<ol>
<li><p>令$R_s$表示服务器与路由器之间的链路速率；$R_c$表示路由器与客户机之间的链路速率。对于这种简单的两链路网络，其吞吐量是<strong>min{$R_c,R_s$}</strong>，也就是说是<strong>瓶颈链路(bottleneck link)</strong>的传输速率。在确定了吞吐量后，我们现在近似地得到从服务器到客户机传输一个$F$比特的大文件所需要的时间是$F$/min{$R_c,R_s$}。得到的表达式是近似的是因为没有考虑分组层次和协议的问题。</p>
</li>
<li><p>服务器以接入速率$R_s$与网络相连，客户机以接入速率$R_c$与网络相连，现在假定计算机网络核心中的所有链路具有非常高的传输速率，远远超过$R_s$和$R_c$。在这个例子中，因为计算机网络的核心就像一个宽大的管子。所以比特从源向目的地流动速率还是$R_s$和$R_c$中的较小者，即min{$R_s,R_c$}。目前，因特网中对吞吐量的限制因素通常是接入网。<br><img src="/images/6a5.png" alt="10个客户机从10个服务器下载文件"></p>
</li>
<li>若有10个服务器和10个客户机与计算机网络核心相连。假设这条链路的传输速率为$R$，再假定所有服务器接入链路的速率都是$R_s$，所有客户机接入链路的速率都是$R_c$。</li>
</ol>
<ul>
<li>如果公共链路的速率$R$很大，比$R_s$和$R_c$大100倍，则每个下载的吞吐量仍是min{$R_s,R_c$}。因为公共链路对10个下载平分其传输速率，假设平分完后的速率小于$R_s$和$R_c$，则吞吐量取决于平分后公共链路传输速率。</li>
</ul>
<h2 id="协议层次和他们的服务模型"><a href="#协议层次和他们的服务模型" class="headerlink" title="协议层次和他们的服务模型"></a>协议层次和他们的服务模型</h2><h3 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h3><p>利用分层的体系结构，我们可以讨论一个定义良好的、大而复杂的系统的特定部分。这种简化本身由于提供模块化而具有很高的价值，这使得由层所提供的服务的实现易于改变。<br>只要该层对其上面的层提供相同的服务，并且使用来自下面层次的相同服务，当某层的实现变化时，该系统的其余部分就可以保持不变。<br>对于大而复杂且需要不断更新的系统，改变服务的实现而不影响该系统其他部分的能力是分层的另一个重要优点。</p>
<h4 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h4><p>为了给网络协议的设计者提供一个结构，网络设计者以<strong>分层(layer)</strong>的方式组织协议及实现这些协议的网络硬件和软件。每层通过在该层中执行某些动作，或直接下层的服务，来提供他的服务。<br>各层的所有协议综合起来被称为协议栈(protocol stack)。因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。</p>
<ol>
<li>应用层<br>应用层是网络应用程序及其应用层协议存留的地方。<br>应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们将这种位于应用层的信息称为<strong>报文(message)</strong>。</li>
<li>运输层<br>运输层提供了在应用程序端点之间传送应用层报文的服务。<br>TCP向他的应用程序提供了面向连接的服务。这种服务包括了应用层报文向目的地确保传输和流量控制。TCP也将长报文划分为短报文，并提供拥塞机制，因此当网络拥塞时，源抑制其传输速率。<br>UPD协议香它的应用程序提供无连接服务。<br>在本书中，我们将运输层称为<strong>报文段(segment)</strong></li>
<li>网络层<br>因特网的网络层负责将称为<strong>数据报(datagram)</strong>的网络层分组从一台主机移动到另一台主机。</li>
<li>链路层<br>为了将分组从一个节点（主机或路由器）移动到数据上的下一个节点，网络层必须依靠链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给 下一个节点。在该下个节点，链路层将数据报上传给网络层。<br>链路层提供的服务取决于应用于该链路的特定链路层协议。<br>链路层分组被称为<strong>帧(frame)</strong>。</li>
<li>物理层<br>物理层的任务是将该帧中的一个一个比特从一个节点移动到下一个节点。该层中的协议仍是链路相关的，并且进一步与链路（例如，双铜绞线、单模光纤）的实际运输媒体相关。</li>
<li>ISO模型<br>因特网协议栈并不是唯一的协议栈，国际标准化组织（ISO）提出计算机网络应组织为大约七层，称为开放系统互连（OSI）。OST参考模型的七层是：应用层、表示层、会话层、运输层、网络层、链路层和物理层。<br>表示层的作用是使通信的应用程序能够解释交换数据的含义，它所提供的服务包括数据压缩、数据加密以及数据描述。<br>会话层提供了数据交换的定界和同步功能，包括建立检查点和恢复方案的方法。</li>
</ol>
<h3 id="报文、报文段、数据报和帧"><a href="#报文、报文段、数据报和帧" class="headerlink" title="报文、报文段、数据报和帧"></a>报文、报文段、数据报和帧</h3><p><img src="/images/6a6.png" alt="主机、路由器和链路层交换机，每个包含了不同的层，反映了不同的功能"><br>在发送主机，<strong>应用层报文(application-layer message)</strong>(图中的M)被传送给运输层。<br>在最简单的情况下，运输层收取报文并附上附加信息（即运输层首部信息，图中的$H_t$），该首部将被接收端的运输层使用。应用层报文和运输层首部信息共同构成了<strong>运输层报文段(transport-layer segment)</strong>。运输层报文段因此封装了应用层报文，<br>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息（图中的$H_n$），形成了<strong>网络层数据报(network-layer datagram)</strong>。<br>该数据报接下来被传递给链路层，链路层当然也增加它自己的链路层首部信息并创建了<strong>链路层帧(link-layer frame)</strong>。<br><em>在每一层，分组具有两种类型的字段：首部字段和<strong>有效荷载字段(payload field)</strong>。有效荷载通常来则上一级的分组。这也说明了<strong>封装(encapsulation)</strong>这一重要概念</em>。</p>
<h2 id="攻击威胁下的网络"><a href="#攻击威胁下的网络" class="headerlink" title="攻击威胁下的网络"></a>攻击威胁下的网络</h2><ol>
<li>坏家伙能够经因特网将恶意软件放入你的计算机<br>设备与因特网相连，接受或发送的数据中包含好的东西和不好的东西，这些不好的东西统称为<strong>恶意软件(malware)</strong>，他能够影响我们的设备。<br>受害主机还可能征召网络上数以千计的类似受害设备，它们被统称为<strong>僵尸网络(botnet)</strong>。<br>大多数恶意软件是<strong>自我复制(self-replicating)</strong>的：一旦它感染了一部主机，就会从那台主机进入更多的主机。</li>
</ol>
<ul>
<li><strong>病毒(virus)</strong>是一种需要某种形式的用户交互来感染用户设备的恶意软件。</li>
<li><strong>蠕虫(worm)</strong>是一种无需任何明显用户交互就能进入设备的恶意软件。</li>
</ul>
<ol>
<li><p>坏家伙能够攻击服务器和网络基础设施<br><strong>拒绝服务(Denial-of-Service,DoS)攻击</strong>是一种宽泛类型的安全性威胁。DoS攻击使得合法用户不能使用网络、主机或其他基础设施部分。<br>大多数因特网DoS攻击属于下列三种：<em>弱点攻击、带宽洪泛、连接洪泛</em>。<br>攻击者还可使用僵尸网络产生<strong>分布式DoS(distributed DoS,DDoS)</strong>去攻击。</p>
</li>
<li><p>坏家伙能够嗅探分组<br><strong>分组嗅探器(packet sniffer)</strong></p>
</li>
<li><p>坏家伙能够伪装层你信任的人<br>一个不可信的接收方（比如说因特网上的一台路由器）接受了分组，用（虚假的）源地址伪装真实的源地址，进而执行某些嵌入在该分组中的命令（比如说修改它的转发表），将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗(IP spoofing)</strong>，它只是一个用户能够冒充另一个用户的多种方式之一。</p>
</li>
<li><p>坏家伙能够修改或删除报文</p>
</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/31/Java_Initialization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/31/Java_Initialization/" class="post-title-link" itemprop="url">Java Initialization</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-31 17:29:20" itemprop="dateCreated datePublished" datetime="2019-08-31T17:29:20+08:00">2019-08-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-01 22:41:07" itemprop="dateModified" datetime="2019-09-01T22:41:07+08:00">2019-09-01</time>
              </span>
            
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>概念： 在创建对象时被自动调用的特殊方法，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能将它自动释放。<br>不接受任何参数的构造器叫做默认构造器，Java文档中通常使用术语无参构造器。但是和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。如果Tree(int)是Tree类中唯一的构造器，那么编译器将不会允许你以其他任何方法创建Tree对象。在Java中，“初始化”和“创建”捆绑在一起，两者不能分离。构造器本身并没有任何返回值。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>任何程序设计语言都具备的一项重要特性就是对名字的运用。当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。在Java里，构造器是强制重载方法名的另一个原因。既然构造器的名字已经由类名决定，就只能有一个构造器名。为了让方法名相同而形式参数不同的构造器同时存在，必须要用到方法重载。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.midview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    Tree()&#123;</span><br><span class="line">        print(<span class="string">"Planting a seedling"</span>);</span><br><span class="line">        height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree(<span class="keyword">int</span> initialHeight)&#123;</span><br><span class="line">        height = initialHeight:</span><br><span class="line">        print(<span class="string">"Creating new Tree that is "</span> + height + <span class="string">" feet tall"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(<span class="string">"Tree is "</span> + height + <span class="string">"feet tall"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        print(s + <span class="string">": Tree is "</span> + height + <span class="string">" feet tall"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>有了方法重载，可以为两者使用相同的名字</em></p>
<h3 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h3><p>重载的方法通过独一无二的<strong>参数类型列表</strong>去让Java便于区分，甚至<strong>参数顺序</strong>不同也足以区分两个方法。<em>不过一般情况下别这么做，因为这会使代码难以维护</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingOrder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, String s)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h3><p><strong>byte8位，short16位，int32位，long64位，float单精度32位，double双精度64位，char单一的16位Unicode字符</strong><br>基本类型能从一个“较小”的类型自动提升至一个“较大”的类型。如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。<strong>char</strong>型略有不同，如果无法找到恰好接受<strong>char</strong>参数的方法，就会把<strong>char</strong>直接提升至<strong>int</strong>型。<br>如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。</p>
<h3 id="以返回值区分重载方法"><a href="#以返回值区分重载方法" class="headerlink" title="以返回值区分重载方法"></a>以返回值区分重载方法</h3><p>根据方法的返回值来区分重载方法是行不通的。</p>
<h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。<br>如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird2</span></span>&#123;</span><br><span class="line">    Bird2(<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">    Bird2(<span class="keyword">double</span> d)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSynthesis</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//! Bird2 b = new Bird2(); //No default</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果按照上述编写会报错。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peeler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Apple <span class="title">peel</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="function">Apple <span class="title">getPeeled</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Peeler.peel(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了将自身传递给外部方法，<strong>Apple</strong>必须使用<strong>this</strong>关键字。<br>可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可用<strong>this</strong>关键字做到这一点。<br>```java<br>public class Flower{<br>    int petalCount = 0;<br>    String s = “initial value”;<br>    Flower(int petals){}<br>    Flower(String ss){}<br>    Flower(String s, int petals){<br>        this(petals);<br>        //! this(s); //Can’t call two!<br>        this.s = s<br>    }<br>}</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">2AM</p>
  <div class="site-description motion-element" itemprop="description">they said the fruit never gon' fall far from the tree</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">2AM</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>






  




























  

  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
      <script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  

  

  


  
  
</body>
</html>
