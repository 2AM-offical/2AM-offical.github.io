<!DOCTYPE html>





<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="they said the fruit never gon&apos; fall far from the tree">
<meta property="og:type" content="website">
<meta property="og:title" content="Room of Requirment">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Room of Requirment">
<meta property="og:description" content="they said the fruit never gon&apos; fall far from the tree">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Room of Requirment">
<meta name="twitter:description" content="they said the fruit never gon&apos; fall far from the tree">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Room of Requirment</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Room of Requirment</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Less is More</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-home">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/16/CSE205W3-ApplicationLayer-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/16/CSE205W3-ApplicationLayer-2/" class="post-title-link" itemprop="url">CSE205W3_ApplicationLayer(2)</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-16 10:55:22" itemprop="dateCreated datePublished" datetime="2019-09-16T10:55:22+08:00">2019-09-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-19 10:59:59" itemprop="dateModified" datetime="2019-09-19T10:59:59+08:00">2019-09-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="DNS-因特网的目录服务"><a href="#DNS-因特网的目录服务" class="headerlink" title="DNS: 因特网的目录服务"></a>DNS: 因特网的目录服务</h2><p>主机的一种识别方法是用它的<strong>主机名（hostname）</strong>，如cnn.com，但主机名提供了很少关于主机在因特网中的信息。因为主机名可能由不定长的字母数字组成，所以路由器很难处理。<br>基于上述原因，主机也可以用<strong>IP地址（IP address）</strong>进行识别。</p>
<h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>DNS协议是应用层协议，它使用客户机/服务器模式在通信的端系统之间运行，在通信的端系统之间通过下面的端到端运输层协议来传输DNS报文。<br>然而在某种意义上，DNS的作用非常不同于Web应用、文件传输应用以及电子邮件应用。不同之处在于，DNS并不直接和用户打招呼。相反，DNS为因特网上的用户应用程序以及其他软件提供一种核心功能，即将主机名转换为它们下面的IP地址。</p>
<p>有两种方式识别主机：通过主机名或者IP地址。人们喜欢便于记忆的主机名标示，而路由器则喜欢定长的、有着层次结构的IP结构。<strong>域名系统（Domain Name System，DNS）</strong>的主要任务就是进行主机名到IP地址转换的目录服务。</p>
<p>DNS是一个由<em>分层</em>的<strong>DNS服务器（DNS server）</strong>实现的分布式数据库。DNS是一个允许主机查询分布式数据库的应用层协议。</p>
<p>DNS所提供的服务：</p>
<ul>
<li>主机名到IP地址的转换</li>
<li><strong>主机别名（host aliasing）</strong>。有着复杂主机名的主机可以拥有一个或多个别名，应用程序可以调用DNS来获得主机别名对应的规范主机名及主机的IP地址。</li>
<li><strong>邮件服务器别名（mail server aliasing）</strong>。电子邮件应用程序调用DNS，对提供的邮件服务器别名进行解析，以获得该主机的规范主机名及其IP地址。</li>
<li><strong>负载分配（load distribution）</strong><br>DNS也用在冗余的服务器（如冗余的Web服务器等）之间进行负载分配。<h3 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h3>DNS的一种简单设计方式是在因特网上只使用一个DNS服务器，该服务器包含所有的映射。在这种集中式设计中，客户机直接将所有查询直接发往单一的DNS服务器，同时该DNS服务器直接对所有的查询客户机做出响应。尽管这种设计方式非常具有吸引力，但它不适用于当今的因特网，因为因特网有着数量巨大（并持续增长）的主机。这种集中式设计的问题包括：</li>
<li><strong>单点故障（a single point of failure)</strong>：如果该DNS服务器故障，整个因特网将随之瘫痪</li>
<li><strong>通信容量（traffic volume)</strong>：单个DNS服务器不得不处理所有的DNS查询</li>
<li><strong>远距离的集中式数据库（distant centralized database)</strong>：查询的地理距离会导致严重的时延</li>
<li><strong>维护（maintenance)</strong>：在单一DNS服务器上运行集中式数据库完全没有可扩展能力<h4 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h4><img src="/images/11/11a1.png" alt="DNS服务器的部分层次结构"><br>为了处理规模问题，DNS使用了大量的DNS服务器，它们以层次方式组织，并分布在全世界范围内。<br>有3种类型的DNS服务器：</li>
<li><strong>根服务器（root name servers)</strong></li>
<li><strong>顶级域（Top-level domain, TLD）服务器</strong>:<br>这些服务器负责顶级域名（如com、org、net、edu和gov）和所有国家的顶级域名（如uk、fr、ca和jp）</li>
<li><strong>权威DNS服务器（Authoritative DNS servers)</strong>:<br>在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构的权威DNS服务器负责保存这些记录。</li>
</ul>
<p>假定一个DNS客户机要确定主机名www.amazon.com的IP地址。粗略来说将发生以下事件。该客户机首先与根服务器之一联系，它将返回顶级域名com的TLD服务器的IP地址。该客户机则与这些TLD服务器之一联系，它将为amazon.com返回权威服务器的IP地址。最后，该客户机为amazon.com联系权威服务器之一，他为主机名www.amazon.com返回IP地址。</p>
<p>还有另一类很重要的DNS，称为<strong>本地DNS服务器（local DNS server）</strong>。<br>本地服务器严格来说并不属于DNS服务器的层次结构，但它对DNS层次结构是很重要的。<br>主机的本地DNS服务器通常“临近”本主机。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中。<br><img src="/images/11/11a2.png" alt="各种DNS服务器的交互"><br>在本例中，为了获得一个主机名的映射，共发送了8份报文：4份查询报文和4份回答报文。<br>本例中也使用了<strong>递归查询（recursive query）</strong>和<strong>迭代查询（iterative query）</strong>。查询通常按照该例子中的模式：从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。</p>
<h4 id="DNS缓存（DNS-caching）"><a href="#DNS缓存（DNS-caching）" class="headerlink" title="DNS缓存（DNS caching）"></a>DNS缓存（DNS caching）</h4><p>为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术。<br>在请求链中，当一个DNS服务器接收一个DNS回答（例如，包含主机名到IP地址的映射）时，DNS服务器能将回答中的信息缓存在本地存储器。如果在DNS服务器中缓存了一个主机名/IP地址对，另一个相同主机名的查询到达该DNS服务器时，该服务器能够提供所要求的IP地址，即使它不是该主机名的权威服务器。<br>由于主机和主机名与IP地址间的映射决不是永久的，所以DNS服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。<br>本地DNS服务器也可以缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根服务器（这经常发生）。</p>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>实现DNS分布式数据库的所有DNS服务器共同存储着<strong>资源记录（Resource Record, RR)</strong>，RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记录。<br>资源记录是一个包含了下列字段的四元组：(Name, Value, Type, TTL)<br>TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。<br>Name和Value的值取决于Type：</p>
<ul>
<li>如果Type=A，则Name是主机名，Value是该主机名的IP地址。因此，一条类型为A的资源记录提供了标准的主机名到IP地址的映射。</li>
<li>如果Type=NS，则Name是域，而Value是知道如何获得该域中主机IP地址的权威DNS服务器的主机名，这个记录用于沿着查询链路进一步路由DNS查询。</li>
<li>如果Type=CNAME，则Value是别名为Name的主机对应的规范主机名</li>
<li>如果Type=MX，则Value是别名为Name的邮件服务器的规范主机名。MX记录允许邮件服务器的主机名具有简单的别名。通过使用MX记录，一个公司的邮件服务器和其他服务器（如它的Web服务器）可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS客户机应当请求一条CNAME记录。</li>
</ul>
<h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p>DNS只有查询和回复报文，并且，查询和回答报文有着相同的格式。<br><img src="/images/11/11a3.png" alt="DNS报文格式"><br>DNS报文中各字段的语义如下：</p>
<ul>
<li>前12个字节是<em>首部</em>区域，其中有几个字段。<br>第一个字段是一个16比特的数，用于标示该查询。这个标识符会被复制到对查询的回答报文中，以便让客户机用它来匹配发送的请求和接收到的回答。标志字段中含有若干标志。<br>1比特的“查询/回答”标志位指出报文是查询报文（0）还是回答报文（1）。<br>在该首部还有4个“数量”字段，这些字段指出了在首部后4类数据区域出现的数量。</li>
<li><em>问题区域</em>包含着正在进行的查询信息。该区域包括：1）名字字段，用于指出正在被查询的主机名字；2）类型字段，用于指出正被询问的问题类型。</li>
<li>在来自DNS服务器的回答报文中，<em>回答区域</em>包含了对最初请求的名字的资源记录。在一个回答报文的回答区域中可以包含多条RR，因为一个主机名可以对应多个IP地址。</li>
<li><em>权威区域</em>包含了其他权威DNS服务器的记录</li>
<li><em>附加区域</em>包含了一些其他有帮助的信息。</li>
</ul>
<h4 id="在DNS数据库中插入记录"><a href="#在DNS数据库中插入记录" class="headerlink" title="在DNS数据库中插入记录"></a>在DNS数据库中插入记录</h4><p>首先要做的事情是在注册登记机构注册域名。<strong>注册登记机构（registrar）</strong>是一个商业实体，它验证域名的唯一性，将域名输入DNS数据库，对所提供的服务收取少量费用。<br>向某些注册登记机构注册域名的时候，需要向该机构提供你基本的权威DNS服务器和辅助权威DNS服务器的名字和IP地址。<br>你也必须确保用于Web服务器的类型A资源记录和用于邮件服务器的类型MX资源记录被输入你的权威DNS服务器中。</p>
<h4 id="DNS攻击"><a href="#DNS攻击" class="headerlink" title="DNS攻击"></a>DNS攻击</h4><ol>
<li>DDoS带宽洪泛攻击，攻击者能够向每个DNS根服务器连续不断地发送大量的分组，从而使大多数合法DNS攻击请求得不到回答。</li>
<li>更有效的DDoS攻击是向顶级域名服务器发送大量的DNS请求。这是因为更难过滤指向DNS服务器的DNS请求，并且顶级域名服务器不像根服务器那样容易被绕过</li>
<li>中间人攻击，攻击者截获来自主机的请求并返回伪造的回答。</li>
<li>DNS毒害攻击，攻击者向DNS服务器发送伪造的回答，诱使服务器在其缓存中保存伪造的记录。3和4难以实现，因为他们要求截获分组或遏制服务器。</li>
<li>充分利用DNS基础设施来对目标主机发起DDoS攻击。在这种攻击中，攻击者向许多权威DNS服务器发送DNS请求，每个请求带有目标主机的假冒源地址。</li>
</ol>
<h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><p>我们通过讨论从单一服务器向大量主机（对等方）分发大文件这个应用来研究P2P<br>在客户机/服务器文件分发中，服务器必须向每个对等方发送该文件的一个拷贝，及服务器承担了极大的负担，并且消耗了大量的服务器带宽。<br>在P2P文件分发中，每个对等方都能够重新分发其所有的该文件的任何部分，从而协助服务器进行分发。</p>
<h4 id="P2P体系结构的扩展性"><a href="#P2P体系结构的扩展性" class="headerlink" title="P2P体系结构的扩展性"></a>P2P体系结构的扩展性</h4><p>我们假设服务器和对等方使用接入链路与因特网相连。其中$u_s$表示服务器接入链路的上载速率，$u_i$表示第$i$个对等方接入链路的下载速率。此外$F$表示被分发的文件长度（以比特计），$N$表示要获得文件拷贝的对等方的数量。<br><strong>分发时间（distribution time）</strong>是$N$个对等方得到文件拷贝所需要的时间。我们可以根据课本上的推导（足够详细）得到</p>
<ol>
<li>客户机/服务器体系结构中的分发时间<script type="math/tex; mode=display">
D_{cs} \geq max\left\{NF/u_s,F/d_{min}\right\}</script>我们取下界为实际分发时间，即<script type="math/tex; mode=display">
D_{cs} = max\left\{NF/u_s,F/d_{min}\right\}</script></li>
<li>在P2P体系结构中，每个对等方都可以帮助服务器来分发文件，也就是说，当一个对等方接收到文件数据的时候，它可以利用自己的上载能力重新将数据分发给其他对等方。<br>P2P体系结构的分发时间<script type="math/tex; mode=display">
D_{P2P} \geq max\left\{F/u_s,F/d_{min},NF/(u_s + \sum_{i=1}^N u_i)\right\}</script>我们取下界为实际的分发时间，即<script type="math/tex; mode=display">
D_{P2P} = max\left\{F/u_s,F/d_{min},NF/(u_s + \sum_{i=1}^N u_i)\right\}</script><img src="/images/11/11a4.png" alt="P2P和客户机/服务器体系结构的分发时间"><br>上图中我们设置了<script type="math/tex">F/U = 1</script>小时，<script type="math/tex">u_s = 10u</script>, <script type="math/tex">d_{min} \geq u_s</script>。<br>对于客户机/服务器体系结构，随着对等方数量的增长，分发时间呈线性增长并且没有界。对于P2P体系结构，最小分发时间不仅总是小于客户机/服务器体系结构的分发时间，而且对任何多的对等方其总是小于1小时。因此采用P2P体系结构是可以拓展的，因为对等方除了是比特的消费者外还能重新分发。<h4 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h4>BitTorrent是一种用于文件分发的流行P2P协议。用BitTorrent的术语来讲参与一个特定文件分发的所有对等方的一个集合称为一个<em>洪流（torrent）</em>。<br>在一个洪流中，对等方彼此下载等长度的<em>文件块</em>，块长度通常为256KB。<br>每个洪流具有一个基础设施节点，称为<em>追踪器（tracker）</em>。当一个对等方加入洪流时，它向追踪器注册，并周期性地通知追踪器它仍在洪流中。<br>当一个新的对等方Alice加入洪流时，追踪器随机地从参与对等方集合中选择一些对等方Alice持有对等方的这张列表，试图与该列表上的对等方创建并行的<strong>TCP连接</strong>。所有与Alice成功地创建连接的对等方为“临近对等方”，临近对等方将随着时间而改变。<br>在任何时刻，每个对等方都具有来自某文件块的自集。Alice周期性地（经TCP）连接询问每个临近对等方它们所具有的块列表，Alice将对她目前还没有的块发出请求（仍通过TCP连接）。<br>Alice将做出两个重要的决定：</li>
<li>她应当向她的邻居请求哪些块呢？<br>Alice使用一种<strong>最稀罕优先（rarest first）</strong>的技术。这种技术的思路是：根据她没有的块从她的邻居中确定最稀罕的块（就是在她的邻居中拷贝数量最少的那些块），并优先请求那些最稀罕的块。</li>
<li>她请求的块应当发送给她的哪些邻居<br>为了决定Alice响应哪个请求，其基本想法是Alice确定其邻居的优先权，这些邻居是那些当前能以<em>最高的速率</em>给她数据的。</li>
</ol>
<p>1】递归迭代？<br>2】分布式数据库<br>3】Type = NS？</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/14/CSE201W2b-B-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/14/CSE201W2b-B-Tree/" class="post-title-link" itemprop="url">CSE201W2b_B+Tree</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-14 19:14:24" itemprop="dateCreated datePublished" datetime="2019-09-14T19:14:24+08:00">2019-09-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-17 20:53:06" itemprop="dateModified" datetime="2019-09-17T20:53:06+08:00">2019-09-17</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p><strong>$B^+$树（$B^+$-tree）</strong>索引结构是在数据插入和删除下仍能保持其执行效率的几种使用最广泛的索引结构之一。B+树采用<strong>平衡树（balanced tree）</strong>结构</p>
<h2 id="B-树的基本要求"><a href="#B-树的基本要求" class="headerlink" title="B+树的基本要求"></a>B+树的基本要求</h2><p>B+树结点最多包含$n - 1$个搜索码值<script type="math/tex">K_1, K_2, ..., K_{n-1}</script>，以及$n$个指针<script type="math/tex">P_1, P_2, ..., P_n</script>,每个结点的搜索码值排序存放。<br><strong>根结点（root）</strong>必须至少有两个子结点<br>在每个<strong>非叶结点（nonleaf node）</strong>至少容纳$\lceil n/2 \rceil$个指针<br>在每个<strong>叶结点（leaf node）</strong>至少容纳$\lceil (n-1)/2 \rceil$个搜索值<br>一个B+树的高度不得超过<script type="math/tex">\lceil log_{\lceil n/2 \rceil} (K) \rceil</script></p>
<h2 id="B-树的查询"><a href="#B-树的查询" class="headerlink" title="B+树的查询"></a>B+树的查询</h2><p><img src="/images/10/10a1.png" alt="B+树的查询"></p>
<h2 id="B-树的更新"><a href="#B-树的更新" class="headerlink" title="B+树的更新"></a>B+树的更新</h2><p><img src="/images/10/10a2.png" alt="B+树的更新"></p>
<ul>
<li><strong>Splitting a leaf node</strong>：</li>
</ul>
<ol>
<li>将$n$个搜索码值和指针（包括插入的）放入一个可以存放的区域$M$，将前$\lceil n/2 \rceil$放入原先的结点，将剩余的放入一个新结点</li>
<li>将新结点视为$p$，将该结点内最小的搜索码值视为$k$，将$(k,p)$放入父结点</li>
<li>如果父结点也满了，就顺级分离。</li>
</ol>
<ul>
<li><strong>Splitting a non-leaf node</strong>:<br>当插入搜索码值和指针到一个已经没有位置的非叶结点$N$时</li>
</ul>
<ol>
<li>将$N$放到一个可以储存$n$个搜索码值和$n+1$个指针的区域$M$</li>
<li>将要插入的$(k,p)$按照排列插入$M$中</li>
<li>将<script type="math/tex">P_1, K_1, ..., K_{\lceil n/2 \rceil - 1}, P_{\lceil n/2 \rceil}</script>从$M$抄写到原来的$N$中</li>
<li>将<script type="math/tex">P_{\lceil n/2 \rceil+1}, K_{\lceil n/2 \rceil+1}, ..., K_n, P_{n+1}</script>从$M$抄写到新的非叶结点$N’$</li>
<li>将(<script type="math/tex">K_{\lceil n/2 \rceil}</script>, $N’$)写到父结点中。</li>
</ol>
<p><em>分离结点的最差情况是整体高度+1</em><br><img src="/images/10/10a3.png" alt="Insertion例子"></p>
<h2 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h2><ul>
<li>删除后，如果该结点的搜索码值过于少，并且该结点可以和它的兄弟结点相结合成一个结点，我们使用<strong>merge siblings</strong>:</li>
</ul>
<ol>
<li>将两个结点的所有搜索值码放入一个搜索值码中，并删除另一个结点。</li>
<li>如果它是一个非叶结点，将两个结点中的父节点拷贝到结合的结点中</li>
<li>将（<script type="math/tex">K_{i-1}, P_i</script>）从父节点中删除，$P_i$是指向原先存在结点的指针，重复上述过程</li>
</ol>
<ul>
<li>删除后，如果该结点的搜索码值过于少，但是又不能和它的兄弟结点相结合成为一个结点，我们使用<strong>redistribute pointers</strong>:</li>
</ul>
<ol>
<li>重新分配它和它兄弟结点的指针使这两个结点都满足最少搜索码值的要求，更新父节点中的搜索码值</li>
<li>如果是<strong>叶结点</strong>：将一个适合的搜索码值从它的兄弟结点中移到该结点里，将父节点中的旧搜索码值替换为合适的搜索码值</li>
<li>如果是<strong>非叶结点</strong>：将父节点中的旧搜索码放入不满的结点中，将一个合适的搜索码值从兄弟结点中移到父节点中。<br><img src="/images/10/10a4.png" alt="Deletion例子1"><br><img src="/images/10/10a5.png" alt="Deletion例子2"><br><img src="/images/10/10a6.png" alt="Deletion例子3"></li>
</ol>
<p>level below root?</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/13/CSE201W2a-Indexing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/13/CSE201W2a-Indexing/" class="post-title-link" itemprop="url">CSE201W2a_Indexing</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-13 22:39:02" itemprop="dateCreated datePublished" datetime="2019-09-13T22:39:02+08:00">2019-09-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-15 15:08:24" itemprop="dateModified" datetime="2019-09-15T15:08:24+08:00">2019-09-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="索引的基本概念"><a href="#索引的基本概念" class="headerlink" title="索引的基本概念"></a>索引的基本概念</h2><p>索引技术用来加快得到所需数据的时间</p>
<p>有两种基本的索引类型</p>
<ul>
<li><strong>顺序索引（an ordered Index）</strong>：基于值的顺序排序</li>
<li><strong>散列索引（a hashing Index）</strong>：基于将值平均分布到若干散列桶中，一个值所属的散列桶是由一个函数决定的，该函数称为散列函数（hash function）。</li>
</ul>
<p>我们将考虑用于顺序索引和散列索引的几种技术。没有哪一种技术是最好的，只能说某种技术对特定的数据库应用是最适合的。对每种技术的评价必须基于下面这些因素：</p>
<ul>
<li><strong>访问类型（access type）</strong>：能有效地支持的访问类型。访问类型可以包括找到具有特定属性值的记录，以及找到属性值落在某个特定范围内的记录。</li>
<li><strong>访问时间（access time）</strong></li>
<li><strong>插入时间（insertion time）</strong></li>
<li><strong>删除时间（deletion time）</strong></li>
<li><strong>空间开销（space overhead）</strong></li>
</ul>
<p>用于在文件中查找记录的属性或属性集称为<strong>搜索码（search key）</strong>。如果一个文件上有多个索引，那么它就有多个搜索码。</p>
<h2 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h2><p>顺序索引按顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。<br>如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为<strong>聚集索引（clustering index）</strong>，聚集索引也被称为<strong>主索引（primary index）</strong>：主索引可以建立在任何搜索码上，一般是主搜索码。<br>搜索码指定的顺序与文件中记录的物理顺序不同的索引称为<strong>非聚集索引（nonclustering index）</strong>或<strong>辅助索引（secondary index）</strong><br>搜索码上有聚集索引的文件称为<strong>索引顺序文件（index-sequential file）</strong></p>
<h3 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h3><p><strong>索引项（index entry）</strong>或<strong>索引记录（index record）</strong>由一个搜索码值和指向具有该搜索码值的一条或多条记录的指针构成。指向记录的指针包括磁盘块的标示和标示磁盘块的内部偏移量。</p>
<ul>
<li><strong>稠密索引（dense index）</strong><br>在稠密索引中，文件中的每个搜索码值都有一个索引项.具有相同搜索码值的其余记录顺序地储存在第一条数据记录之后。<br>在稠密非聚集索引中，索引必须储存指向所有具有相同搜索码值的记录的指针列表</li>
<li><strong>稀疏索引（sparse index）</strong><br>在稀疏索引中，只为搜索码的某些值（一般是一个块一个）建立索引项。<strong>只有当关系按搜索码排列顺序储存时才能使用稀疏索引。</strong><br>为了定位一条记录，我们找到其最大搜索码值小于或等于所查找记录的搜索码值的索引项。然后从该索引项指向的记录开始，沿着文件中的指针查找，直到找到所需记录为止。</li>
</ul>
<p>利用稠密索引通常可以比稀疏索引更快地定位一条记录。但是，稀疏索引也有比稠密索引优越的地方：它所占空间较小，并且插入和删除时所需的维护开销也较小。<br><img src="/images/9/9a1.png" alt="稠密索引和稀疏索引的比较"></p>
<h3 id="辅助索引（Secondary-Index）"><a href="#辅助索引（Secondary-Index）" class="headerlink" title="辅助索引（Secondary Index）"></a>辅助索引（Secondary Index）</h3><p><strong>辅助索引必须是稠密索引。</strong><br>候选码上的辅助索引看起来和稠密聚集索引没有太大的区别，只不过索引中一系列的连续值指向的记录不是连续存放的。<br>我们可以用一个附加的间接指针层来实现非候选码的搜索码上的辅助索引。在这样的辅助索引中，指针并不指向文件，而是指向一个包含文件指针的桶。<br>如果文件具有多个索引，无论何时修改文件，它的每个索引都必须更新？<br>用辅助索引的顺序扫描较为昂贵，每个记录也许都要从一个新的数据块中提取。</p>
<h3 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h3><p>如果索引小到可以放到主存里，搜索一个索引项的时间就会很短。<br>但是如果索引过大而不能放到主存中，那么当需要时，就必须从磁盘中取出索引块。于是一次搜索需要多次读取磁盘块。<br>解决该问题，我们在原始的内层索引上构造一个稀疏的外层索引，索引项是有序的，这使得外层索引可以是稀疏的。<br>如果文件极其庞大，甚至外层索引也可能达到不能装入主存，可以创建另一级索引。事实上，可以根据需要多次重复该过程。具有两级或两级以上的索引称为<strong>多级（multilevel）</strong>索引。<br>多级索引的插入和删除：在插入和删除时，系统对底层索引更新和普通的一样，接下来的每一层都要随之改变。</p>
<p>1】每个索引都必须更新？</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/09/CSE205W2-ApplicationLayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/09/CSE205W2-ApplicationLayer/" class="post-title-link" itemprop="url">CSE205W2_ApplicationLayer</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-09 13:10:18" itemprop="dateCreated datePublished" datetime="2019-09-09T13:10:18+08:00">2019-09-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-15 15:08:39" itemprop="dateModified" datetime="2019-09-15T15:08:39+08:00">2019-09-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><p>研究网络应用程序核心是能够运行在不同的端系统和通过网络彼此通信的程序。（Write programs that: Run on different end systems and Communicate over network.）<br>重要的是，你不用写在网络核心设备（如路由器或链路层交换机）上运行的软件。</p>
<h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><h3 id="客户机-服务器体系结构（client-server-architecture）"><a href="#客户机-服务器体系结构（client-server-architecture）" class="headerlink" title="客户机/服务器体系结构（client-server architecture）"></a>客户机/服务器体系结构（client-server architecture）</h3><ul>
<li>服务器（server)</li>
</ul>
<ol>
<li>在客户机/服务器体系结构中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为<em>客户机</em>的主机请求。</li>
<li>服务器具有固定的、周知的地址，称为IP地址</li>
<li>服务器的性能优异</li>
</ol>
<ul>
<li>客户机（clients）</li>
</ul>
<ol>
<li>服务器需要服务来自于许多客户机的主机请求</li>
<li>客户机主机既可能有时打开，也可能总是打开</li>
<li>客户机相互之间不直接通信</li>
<li>可能间歇性地与网络相连</li>
<li>可能拥有动态的地址</li>
</ol>
<h3 id="P2P体系结构（P2P-architecture"><a href="#P2P体系结构（P2P-architecture" class="headerlink" title="P2P体系结构（P2P architecture)"></a>P2P体系结构（P2P architecture)</h3><p>在<em>P2P体系结构</em>中，对总是打开的基础设施服务有最小的（或者没有依赖）。相反，任意间断连接的主机——称为对等方，直接相互通信。因为这种对等方通信不必通过专门的服务器，所以该体系被称为对等方到对等方（简称为对等）。<br>P2P体系结构的最突出特性之一是它的<em>自扩展性（self-scalablity）</em>。在一个P2P文件共享应用中，尽管每个对等方都由请求文件产生负载，但每个对等方向其他对等方分发文件也为系统增加了服务能力。</p>
<h3 id="进程通信（processes-communicating）"><a href="#进程通信（processes-communicating）" class="headerlink" title="进程通信（processes communicating）"></a>进程通信（processes communicating）</h3><p>进程可以被认为是运行在端系统中的程序。当进程运行在相同的端系统上的时候，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。<br>不同端系统上的进程通过跨越计算机网络交换<strong>报文（message）</strong>，发送进程创建并向网络中发送报文，接收进程接收这些报文并可能负责回送报文。</p>
<ol>
<li>客户机和服务器进程<br>网络应用程序是由成对的进程组成，这些进程通过网络相互发送报文。对每对通信进程，我们通常将这两个进程之一标示为<strong>客户机（client）</strong>，而另一个进程标示为<strong>服务器（server）</strong>。<br><em>在给定的一对进程之间的通信会话中，发起通信（即在该会话开始时与其他进程联系）的进程被标示为<strong>客户机</strong>，在会话开始时等待联系的进程是<strong>服务器</strong>。</em></li>
<li>进程与计算机网络之间的接口<br>多数应用程序由通信进程组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为<strong>套接字（socket）</strong>的软件接口在网络上发送和接收报文。套接字是同一台主机内应用层与运输层之间的接口。由于该套接字是在网络上建立网络应用程序的可编程接口，因此也将该套接字称为应用程序和网络之间的<strong>应用程序编程接口（Application Programming Interface, API)</strong>.<br>应用程序开发者可以控制套接字在<em>应用层</em>端的所有东西，但是对该套接字的<em>运输层</em>端几乎没有控制</li>
</ol>
<h3 id="进程寻址（Addressing-processes）"><a href="#进程寻址（Addressing-processes）" class="headerlink" title="进程寻址（Addressing processes）"></a>进程寻址（Addressing processes）</h3><p>为了识别接收进程，需要定义两种信息：</p>
<ol>
<li>该主机的名称或地址，<br>在因特网中，主机是用<strong>IP地址（IP address）</strong>进行标识。IP地址是用来<em>唯一</em>标识主机的32位比特数。</li>
<li>用来指定目的主机上接收进程的标示。<br>因为通常在一台主机能够运行许多网络应用程序，目的地<strong>端口号（port number）</strong>就是服务于识别运行在主机上的接收进程。已经给流行的应用程序分配了特定的端口号。例如，Web服务进程用的是80号端口</li>
</ol>
<h3 id="应用层协议（application-layer-protocol）"><a href="#应用层协议（application-layer-protocol）" class="headerlink" title="应用层协议（application-layer protocol）"></a>应用层协议（application-layer protocol）</h3><p>应用层协议定义了在不同端系统上的应用程序进程如何相互传递报文：</p>
<ul>
<li>交换的报文类型，如请求报文和响应报文。</li>
<li>各种报文类型的语法，如报文中的各个字段及其详细描述</li>
<li>字段的语义，即包含在字段中的信息的含义</li>
<li>进程何时、如何发送报文及对报文进行响应的规则<br>有些应用层协议是由RFC文档定义的，因此它们位于公共领域。例如，Web的应用层协议HTTP（超文本传输协议[RFC 2616]）就作为一个RFC供大家使用。<br>还有很多其他应用层协议是专用的，不能随意应用于公共领域。例如，很多现有的P2P文件共享系统使用的是专用应用层协议。<br>区分网络应用和应用层协议是很重要的。应用层协议只是网络应用中的一部分。</li>
</ul>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><p>应用程序服务要求进行分类：</p>
<ul>
<li>可靠数据传输<br>对于某些应用，必须确保由应用程序的一端发送的数据正确地、完全地交付给该应用程序的另一段。如果一个协议提供了这样的确保数据交付服务，就提供了<strong>可靠数据传输（reliable data transfer）</strong>。当一个运输层协议提供这种服务时，发送进程只要将其数据传递到套接字，就可以相信该数据将能无差错地到达接收进程。<br>当一个运输层协议不提供可靠数据传输时，由发送进程发送的数据可能不能到达接收进程。对于<strong>容忍丢失的应用（loss-tolerant application）</strong>来说这是可以接受的。</li>
<li>吞吐量<br>两个进程在一条网络路径上进行通信会话时，可用吞吐量就是发送进程能够向接收进程交付比特的速率。运输层协议能够以某种特定的速率提供确保的可用吞吐量。<br>如果运输层协议不能提供这种吞吐量，那么该应用程序或以较低速率（并且接收带宽也必须足以维持这种较低的编码速率）进行编码，或应当放弃发送。<br>具有吞吐量要求的应用程序称为<strong>带宽敏感的应用（bandwidth-sensitive application）</strong>，能够根据需要充分利用可供使用的吞吐量的应用程序称为<strong>弹性应用（elastic application）</strong>。<em>电子邮件、文件传输以及Web传输都属于弹性应用</em></li>
<li>定时<br>运输层协议也能提供定时保证。例如，可以设置发送方注入套接字中的每个比特到达接收方的套接字不迟于100ms。<br>这种服务对于交互式实时应用程序非常适用，例如，对于因特网电话、虚拟环境、电视会议和多方游戏。<br>在非实时的应用中，较低时延总要比较高时延好，但对端到端的时延没有严格的约束。</li>
<li>安全性<br>这种服务将对发送进程和接收进程保密，以防发送进程和接收进程以某种方式观察到数据。运输层协议也能提供除了机密性以外的其他安全性服务，包括数据完整性和端点鉴别<br><img src="/images/8/8a1.png" alt="部分网络技术的要求"></li>
</ul>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><p>因特网（更一般说是TCP/IP网络）上的应用使用了两个运输层协议：UDP和TCP。</p>
<ol>
<li>TCP服务</li>
</ol>
<ul>
<li>可靠数据传输服务（reliable transport）：进行通信的进程依靠TCP协议，无差错、按照适当顺序交付发送的数据。当应用程序的一端通过套接字传送一个字节流时，它能够依靠TCP协议将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</li>
<li>面向连接服务（connection-oriented）：使用TCP协议时，在应用层数据报文开始流动之前，其客户机程序和服务器程序之间相互交换运输层控制信息。这个所谓的握手过程提示客户机和服务器做好传输分组的准备。在握手阶段后，就在两个进程的套接字之间建立了一个<strong>TCP连接（TCP connection）</strong>。当应用程序结束报文发送时，必须拆除该连接。</li>
<li>拥塞控制机制（congestion transport）：当发送方和接收方之间的网络出现拥塞时，TCP协议的拥塞控制机制会抑制发送进程（客户机或服务器），它会试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。<br><em>TCP并不提供定时服务，确保最小可用吞吐量和加密机制</em><br><em>人们已经研制了TCP的加强版本，称为<strong>安全套接字层（Secure Socket Layer，SSL）</strong>。用SSL加强后的TCP不仅能够做传统TCP所能做的一切，而且还提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别，这种加强是在应用层上实现的</em></li>
</ul>
<ol>
<li>UPD服务<br>UDP是一种不提供不必要服务的轻量级运输层协议，它仅提供最小服务。<br>UDP协议提供的是不可靠数据传输服务。<br>UDP没有拥塞控制机制，所以发送端可以以任何速率向其下面的层（网络层）注入数据。因为实时应用通常可以忍受一定的数据丢失，同时有最低速率的要求，所以开发者有时在这种应用程序中会选择使用UDP协议，以避开TCP协议的拥塞控制机制和分组开销。</li>
</ol>
<p><img src="/images/8/8a2.png" alt="流行的因特网应用及其应用层协议和支撑的应用层协议"></p>
<h2 id="Web应用和HTTP协议"><a href="#Web应用和HTTP协议" class="headerlink" title="Web应用和HTTP协议"></a>Web应用和HTTP协议</h2><p><strong>Web页面（Web page，也叫文档）</strong>是由<strong>对象（object）</strong>组成的。<br>对象简单来说就是文件，如HTLML文件、JPEG图形文件、Java小程序或视频片段文件，这些文件可以通过一个URL地址寻址。<br>多数Web页面包含一个<strong>基本HTML文件（base HTML file）</strong>以及几个引用对象。<br>例如，如果一个Web页面包含HTML文本和5个JPEG图形文件，那么这个Web页面有6个对象：一个基本HTML文件加5个图形。在基本HTML文件中通过对象的URL地址对对象进行引用。每个URL地址由两部分组成：存放对象的服务器主机和对象的路径名<br><img src="/images/8/8a3.png" alt="URL地址例子"><br><strong>Web浏览器（Web browser，如Internet Explore）</strong>实现了HTTP的客户机端。Web服务器（Web server）用于储存Web对象，每个对象由URL寻址。Web服务器实现了HTTP的服务器端。</p>
<h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>Web的应用层协议是<strong>超文本传输协议（HyperText Transfer Protocol, HTTP)</strong>。<br>HTTP协议由两部分程序实现：一个客户机程序和一个服务器程序，他们运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的格式以及客户机和服务器是如何进行报文交换的。<br>HTTP使用TCP作为它的支撑运输层协议<br>服务器向客户机发送被请求的文件时，并不储存任何关于该客户机的状态信息。因为一个HTTP服务器并不保存关于客户机的任何信息，所以我们说HTTP是一个<strong>无状态协议（stateless protocol）</strong>。<br>Web服务器总是打开的，具有一个固定的IP地址，它服务于数以百万记的不同浏览器。</p>
<h3 id="非持久连接和持久连接"><a href="#非持久连接和持久连接" class="headerlink" title="非持久连接和持久连接"></a>非持久连接和持久连接</h3><ul>
<li>非持久连接<br><img src="/images/8/8a4.png" alt="非持久连接例子"><br>每个TCP连接在服务器返回对象后关闭，即该连接并不为其他的对象而持续下来。<br>如果客户机获得多个对象需要建立多个连接</li>
</ul>
<p><strong>往返时间（Round-Trip Time，RTT）</strong>：一个小分组从客户机到服务器再回到客户机所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延<br><img src="/images/8/8a5.png" alt="请求并接收一个HTML文件所需要的时间"><br>如图所示，浏览器在浏览器和Web服务器之间发起一个TCP连接，其中涉及一个“三次握手”过程，即客户机向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应，最后客户机向服务器返回确认。完成了三次握手的前两个部分后，客户机将三次握手的第三个部分（确认）与一个HTTP请求报文结合起来发送到该TCP连接。一旦该请求报文到达服务器，服务器向该TCP连接发送HTML文件。<br>粗略地讲，总的响应时间就是两个RTT加上服务器传输HTML文件的时间。</p>
<p>非持久连接的缺点：必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户机和服务器都要分配TCP的缓冲区和变量，这给服务器带来了严重的负担。每一个对象的传输时延为两个RTT，其中一个用于建立TCP，另一个RTT用于请求和接收一个对象。</p>
<ol>
<li>持久连接<br>在持久连接的情况下，服务器在发送响应后应保持该TCP连接打开。在相同的客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。对这些对象的请求可一个接一个地发出，而不必等待未决请求的回答（流水线）。<em>一般来说，如果一个连接经过一定时间间隔仍未被使用，HTTP服务器就关闭连接</em>。</li>
</ol>
<h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p>HTTP规约[RFC 2616]包含了对HTTP报文格式的定义。HTTP报文有两种：请求报文和响应报文</p>
<ul>
<li>HTTP请求报文<br><img src="/images/8/8a6.png" alt="HTTP请求报文"><br>HTTP请求报文第一行叫做<strong>请求行（request line）</strong>，请求行有三个字段：方法字段、URL字段和HTTP协议版本字段。方法字段可以取值GET、POST、HEAD、PUT和DELETE。绝大部分的HTTP请求报文使用GET方法。在URL字段填写该对象的URL地址。<br>第一行后继的行叫做<strong>首部行（header line）</strong>。</li>
</ul>
<p><img src="/images/8/8a7.png" alt="HTTP请求报文的通用格式"><br>上图展示的是请求报文的通用格式。<br>在首部行后有一个“实体主体”（entity body）。使用GET方法时实体主体为空，而使用POST方法时才使用，HTTP客户机常常在用户提交表单时使用POST方法。例如，用户向搜索引擎提供搜索关键词。在使用POST方法的报文中，用户仍可以向服务器申请一个Web页面，但Web页面的特定内容依赖于用户在表单字段中输入的内容。<br>HEAD方法类似于GET方法。应用程序开发者常用HEAD方法进行故障跟踪。<br>PUT方法常与Web发行工具联合使用，用户利用它来将对象上传到指定的Web服务器上指定的路径。PUT方法也被应用程序用来向Web服务器上传对象。<br>利用DELETE方法，用户或者应用程序可以删除Web服务器上的对象。</p>
<ul>
<li>HTTP响应报文<br>响应报文分成三个部分：一个状态初始行（status line）、6个首部行（header line），然后是<strong>实体主体（entity body）</strong>。<br>状态行有三个字段：协议版本、状态码和相应服务信息。</li>
</ul>
<h3 id="用户与服务器的交互：cookie"><a href="#用户与服务器的交互：cookie" class="headerlink" title="用户与服务器的交互：cookie"></a>用户与服务器的交互：cookie</h3><p>HTTP服务器是无状态的，若一个Web站点通常希望能够识别用户，HTTP使用cookie来满足这一需求<br>cookie技术有4个组成部分：</p>
<ol>
<li>在HTTP响应报文中有一个cookie首部行</li>
<li>在HTTP请求报文中有一个cookie首部行</li>
<li>在用户端系统中保留一个cookie文件，由用户的浏览器管理</li>
<li>在Web站点有一个后端数据库。<br><img src="/images/8/8a8.png" alt="用cookie保持用户状态"></li>
</ol>
<h3 id="Web缓存器（代理服务器）"><a href="#Web缓存器（代理服务器）" class="headerlink" title="Web缓存器（代理服务器）"></a>Web缓存器（代理服务器）</h3><p><strong>Web缓存器（Web cache）</strong>也叫<strong>代理服务器（proxy server）</strong>，它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘储存空间，并在该储存空间中保存所有最近请求过的对象的拷贝。可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。1）如果Web缓存器检查本地是否储存了该对象拷贝。如果有，Web缓存器就用HTTP响应报文向客户机浏览器返回该对象。2）如果Web缓存器没有该对象，他就与初始服务器打开一个TCP连接。Web缓存器则在TCP连接上发送则在TCP连接上发送获取该对象的HTTP请求。在收到请求后，初始服务器向Web缓存器发送具有该对象的HTTP响应。<br><img src="/images/8/8a9.png" alt="客户机通过Web缓存器请求对象"><br>注意到Web缓存器既是服务器又是客户机。<br>一般而言，Web缓存器由ISP购买并安装。<br>在因特网上部署Web缓存器的原因：</p>
<ol>
<li>Web缓存器可以大大减少对客户机请求的响应时间，特别是当客户机在于初始服务器之间的瓶颈带宽远低于客户机与Web缓存器之间的瓶颈带宽时更是如此。</li>
<li>Web缓存器可以大大减少一个机构内部网与因特网接入链路上的通信量。通过减少通信量，该机构就不必急于增加带宽，因此会降低费用。</li>
<li>Web缓存器能从整体上大大降低因特网上的Web流量，从而改善了所有应用的性能。</li>
</ol>
<p>对于Web缓存器优点的例子可以通过看书来进一步理解，书中已足够详细。</p>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>HTTP协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是<strong>条件GET（conditional GET）</strong>方法<br>如果1）请求报文使用GET方法；2）请求报文中包含一个If-modified-since：首部行。那么这个HTTP请求报文就是一个条件GET请求报文。<br>在一段时间后请求一个已被储存在Web缓存器中的对象时，该缓存器通过发送一个条件GET给服务器，执行最近检查，首部行中包括If-modified-since：储存对象时对象的最后修改时间。接下来，Web 服务器向该缓存器发送一个响应报文，该报文状态行中状态码和响应状态信息的值为304 Not Modified时，它告诉缓存器可以使用该对象，否则向Web缓存器发送更改后的对象。</p>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮件系统的3个主要组成部分：<strong>用户代理（user agent）</strong>、<strong>邮件服务器（mail server）</strong>和<strong>简单邮件传输协议（Simple Mail Transfer Protocol, SMTP)</strong>。</p>
<ul>
<li>用户代理允许用户阅读、回复、转发、保存和撰写报文</li>
<li>邮件服务器组成了电子邮件体系的核心。每个接收方在其中的某个服务器上有一个<strong>邮箱（mailbox）</strong>，邮箱管理和维护发送给接收方的报文。如果发送方的服务器不能将邮件交付到接收方的服务器时，发送方的邮件服务器在一个<strong>报文队列（message queue）</strong>中保持该报文并在以后尝试再次发送。</li>
<li>SMTP</li>
</ul>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件，端口号25。<br>SMTP一般不使用中间邮件服务器发送邮件。如果接收方的邮件服务器没有开机，该报文会保留在发送方的邮件服务器上并在稍后进行新的尝试，这意味着邮件并不在中间的某个服务器上存留。<br>使用SMTP将一个报文从发送邮件服务器传送到接收邮件服务器有以下步骤：</p>
<ol>
<li>如果服务器没有开机，客户机会在稍后继续尝试连接。一旦连接建立，服务器和客户机就执行一些应用层的握手。在SMTP握手的阶段，SMTP客户机指明发送方的邮件地址（产生报文的那个人）和接收方的邮件地址。</li>
<li>一旦该SMTP客户机和服务器彼此介绍之后，客户机就发送该报文。SMTP可以利用TCP提供的可靠数据传输无差错的将邮件投递到接收服务器。</li>
<li><p>该客户机如果有另外的报文要发送到该服务器，就在该相同的TCP连接上重复这种处理，否则，它指示TCP关闭连接。</p>
<p>STMP客户机（C）和STMP服务器（S）之间交换脚本使用的是ASCII码<br>SMTP用的是持久连接：如果发送邮件服务器有几个报文发往同一个接收邮件服务器，它可以通过同一个TCP连接发送所有的这些报文。</p>
<p>SMTP限制所有邮件报文的主体部分（不只是其首部）只能采用简单的7位ASCII码表示。</p>
</li>
</ol>
<h3 id="SMTP和HTTP进行对比"><a href="#SMTP和HTTP进行对比" class="headerlink" title="SMTP和HTTP进行对比"></a>SMTP和HTTP进行对比</h3><ol>
<li>当进行文件传输时，HTTP和SMTP都是用持久连接</li>
<li>它们在建立TCP连接的时候都有握手的过程？</li>
<li>HTTP主要是一个<strong>拉协议（pull protocol）</strong>，即人们可以在方便的时候装载Web服务器上的信息，也就是说，用户使用HTTP从该服务器拉取信息。<br>SMTP基本上是一个<strong>推协议（push protocol）</strong>，即发送邮件服务器把文件推向接收邮件服务器</li>
<li>SMTP要求每个报文（包括它们的主体）都使用7为ASCII码格式。HTTP数据则没有这个限制</li>
<li><p>HTTP把每个对象封装到它自己的HTTP响应报文中，而因特网电子邮件则把所有报文对象放在一个报文之中。</p>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>首部行储存环境信息在报文主体的前面，这些行由RFC822定义，首部行和该报文主体用空行（即回车换行）进行分隔。RFC822定义了邮件首部行及其语义解释的精确格式。<br>某些关键词是必须的，有些则是可选的。<br>这些首部行不同于SMTP的握手协议。<br>在报文首部之后，紧接着是一个空白行，然后是以ACSII格式表示的报文主体。</p>
</li>
</ol>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>有多个流行的邮件访问协议来使接收方的用户代理可从邮件服务器中取出邮件：<strong>第三版的邮局协议（Post Office Protocol-Version 3）</strong>、<strong>因特网邮件访问协议（Internet Mail Access Protocol, IMAP)</strong>以及HTTP。<br><img src="/images/8/8a10.png" alt="电子邮件协议及其通信实体"></p>
<ol>
<li>POP3<br>POP3是一个非常简单的邮件访问协议，由RFC1939进行了定义。<br>随着TCP连接的创建，POP3按照几个阶段进行工作：</li>
</ol>
<ul>
<li>特许（authorization）阶段<br>用户发送（以明文形式）用户名和口令以鉴别用户。<br>特许阶段有两个主要的命令：use<user name>和pass<password></password></user></li>
<li>事务处理阶段<br>用户代理取回报文，在这个阶段，用户代理还能进行以下操作：对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。<br>使用POP3的用户代理通常由用户配置为“下载并删除”或者“下载并保留”方式。<br>在特许阶段以后，用户代理仅使用四个命令：list、retr、dele和quit</li>
<li>更新阶段<br>它出现在P客户机发出了quit命令之后，目的是结束该POP3会话；这时，邮件服务器删除那些被标记为删除的报文。</li>
</ul>
<p>在POP3中，用户代理发出一些命令，服务器对每个命令做出回答。回答可能是两种：+OK（有时后面还跟有服务器到客户机的数据），服务器用它来指示前面的命令是正常的；-ERR，服务器用它来指示前面的命令出现了差错。</p>
<ol>
<li>IMAP<br>POP3没有给用户提供任何创建远程文件夹以及为报文指派文件夹的方法。<br>IMAP服务器把每个报文与一个文件夹联系起来，IMAP服务器把所有报文都储存在服务器中。<br>IMAP服务器维护了IMAP会话的用户状态信息，例如，文件夹的名字以及哪个报文与哪个文件夹相关联。<br>IMAP的另一个重要特性是它具有允许用户代理获取报文组件的命令</li>
</ol>
<p>1】定时和吞吐量的区别<br>2】对端到端的时延没有严格的约束<br>3】为什么说UPD没有提供吞吐量的保证<br>4】持久连接的缺点<br>5】为什么说报文是用普通的ASCII码书写的<br>6】用表单生成的请求报文不需要使用POST方法<br>7】响应报文主体包含了所请求对象的本身<br>8】how to keep state<br>9】Internet dense with caches: enables “poor” content providers to effectively deliver content (so too does P2P file sharing)<br>10】POP3 is stateless across sessions<br>11】IMAP和POP3的区别</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/05/CSE201W1-Storage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/05/CSE201W1-Storage/" class="post-title-link" itemprop="url">CSE203W1_Storage</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-05 16:36:34" itemprop="dateCreated datePublished" datetime="2019-09-05T16:36:34+08:00">2019-09-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-15 15:08:22" itemprop="dateModified" datetime="2019-09-15T15:08:22+08:00">2019-09-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="数据存储和数据存取"><a href="#数据存储和数据存取" class="headerlink" title="数据存储和数据存取"></a>数据存储和数据存取</h1><h2 id="物理存储介质概述"><a href="#物理存储介质概述" class="headerlink" title="物理存储介质概述"></a>物理存储介质概述</h2><ol>
<li><p><strong>高速缓存器(cache)</strong> 高速缓存器是最快最昂贵的储存介质。高速缓存器一般很小，由计算机系统硬件来管理它的使用。</p>
</li>
<li><p><strong>主存储器(main memory)</strong> 主存储器是用于存放可处理的数据的储存介质。通用机器指令在主储存器上执行。如果发生电源故障或者系统崩溃，主存储器中的内容通常会丢失。</p>
</li>
<li><p><strong>快闪存储器(flash memory)</strong> 快闪存储器不同于主存储器的地方是在电源关闭（或故障）时数据可以保存下来。</p>
</li>
<li><p><strong>磁盘存储器(magnetic-disk storage)</strong> 用于长期联机数据存储的主要介质是磁盘。通常整个数据库都存储在磁盘上，为了能够访问数据，系统必须将数据从磁盘移动到主存储器。在完成指定的操作后，修改过的数据必须写回磁盘。磁盘存储器不会因为系统故障和系统崩溃丢失数据。磁盘存储设备本身有时有可能会发生故障，导致数据的损坏，但是发生磁盘故障的概率比发生系统崩溃的概率小很多。</p>
</li>
<li><p><strong>光学存储器(optical storage)</strong><br>光学存储器最流行的形式是光盘(Compact Disk, CD)，它可以容纳大约700MB的数据，播放约80分钟。<br>数字视频光盘(Digital Video Disk, DVD)的每一盘面可以容纳4.7GB或8.5GB的数据。<br>可以用数字万能光盘(digital versatile disk)代替数字视频光盘(digital video disk)作为DVD的全称，因为DVD可以存储任何数字数据而不是仅仅视频数据。<br>数据通过光学的方法储存到光盘上，并通过激光器读取。</p>
</li>
<li><p><strong>磁带存储器(tape storage)</strong> 磁带存储器主要用于备份数据和归档数据。</p>
</li>
</ol>
<p><img src="/images/7/7a1.png" alt="储存设备层次结构"><br>根据不同储存介质的速度和成本，可以把它们按层次结构组织起来。层次越高，这种存储介质的成本就越贵，但是速度就越快。当我们沿着层次结构向下，储存介质每比特的成本下降，但是访问时间会增加。</p>
<h2 id="磁盘和闪存"><a href="#磁盘和闪存" class="headerlink" title="磁盘和闪存"></a>磁盘和闪存</h2><h3 id="磁盘的物理特性"><a href="#磁盘的物理特性" class="headerlink" title="磁盘的物理特性"></a>磁盘的物理特性</h3><p><img src="/images/7/7a2.png" alt="磁盘移动头机制"><br>磁盘上的每一个<strong>盘片(platter)</strong>是扁平的圆盘，它的两个表面都覆盖着磁性物质，信息就记录在表面上，盘片由硬金属或玻璃制成。<br>盘片的表面从逻辑上划分为<strong>磁道(track)</strong>，磁道又划分为<strong>扇区（sector)</strong>。<em>扇区是从磁盘读出和写入信息的最小单位</em>。<br>通过反转磁性物质化的方向，<strong>读写头（read-write head）</strong>将信息磁化存储到扇区中。磁盘的每个盘片的每一面都有一个读写头，读写头通过在盘片上移动来访问不同的磁道。一张磁盘通常包括很多个盘片，所有磁道的读写头安装在一个称为<strong>磁盘臂（disk arm）</strong>的单独装置上，并且一起移动。安装在转轴上的所有磁盘盘片和安装在磁盘臂上的所有读写头统称为<strong>磁头-磁盘装置（head-disk assembly）</strong><br>因为所有盘片上读写头一起移动，所以当某一盘片的读写头在第$i$条磁道上时，所有其他盘片的读写头也都在各自盘片的第$i$条磁道上。因此，所有盘片的第$i$条磁道和在一起称为第$i$个<strong>柱面（cylinder）</strong>。<br><strong>磁盘控制器（disk controller）</strong>作为计算机系统和实际的磁盘驱动器硬件之间的接口。</p>
<h3 id="磁盘性能的度量"><a href="#磁盘性能的度量" class="headerlink" title="磁盘性能的度量"></a>磁盘性能的度量</h3><p>磁盘质量的主要度量指标是容量、访问时间、数据传输率和可靠性<br><strong>访问时间（access time）</strong>是从发出读写请求到数据开始传输之前的时间。<br><em>Access time = Seek time + Rotational latency + (Transfer time)</em></p>
<ol>
<li><p><strong>寻道时间（Seek time）</strong>：为了访问（即读或写）磁盘上指定扇区的数据，磁盘臂首先必须移动，以定位到正确的磁道，磁盘臂重定位的时间称为<strong>寻道时间</strong>。从最里面的磁道到最外面的磁道是最糟糕的情况。<strong>平均寻道时间（Average seek time）</strong>是寻道的平均值，如果考虑读写头开始移动和结束移动所花费的时间，平均寻道时间大约是最长寻道时间的1/2.</p>
</li>
<li><p><strong>旋转等待时间（rotational latency time）</strong>：一旦读写头到达了所需的磁道，等待访问的扇区出现在读写头下所花费的时间称为<strong>旋转等待时间</strong>。平均情况下，磁盘需要旋转半周才能使所要访问的扇区开始处于读写头的下方。因此磁盘的<strong>平均旋转等待时间</strong>是磁盘旋转一周时间的1/2。</p>
</li>
<li><p><strong>数据传输率（data-transfer rate）</strong>是从磁盘获得数据或者向磁盘储存数据的速率。在大部分情况下，数据传输率远小于寻道时间和旋转等待时间。</p>
</li>
</ol>
<h3 id="磁盘块访问的优化"><a href="#磁盘块访问的优化" class="headerlink" title="磁盘块访问的优化"></a>磁盘块访问的优化</h3><p>磁盘I/O请求是由文件系统和大多数操作系统具有的虚拟内存管理器产生的。每个请求指定了要访问的磁盘地址，这个地址是以<em>块号</em>的形式提供的。一个<strong>块（block）</strong>是一个逻辑单元，它包含固定数目的连续扇区。块大小在512字节到几KB之间。数据在磁盘和主储存器之间以块为单位传输。<br><em>Smaller blocks: more transfers from disk</em><br><em>Larger blocks: more space wasted due to partially filled blocks</em></p>
<p><strong>磁盘臂调度（disk-arm-scheduling）算法</strong>试图把对磁道的访问按照能增加可以处理的访问数量的方式排序<br><strong>电梯算法（elevator algorithm）</strong>是最常使用的算法</p>
<h2 id="文件和记录的组织"><a href="#文件和记录的组织" class="headerlink" title="文件和记录的组织"></a>文件和记录的组织</h2><h3 id="文件组织（file-organization）"><a href="#文件组织（file-organization）" class="headerlink" title="文件组织（file organization）"></a>文件组织（file organization）</h3><p>为了减少块访问时间，我们可以按照与预期数据访问方式最接近的方式来组织磁盘上的块。例如，如果我们预计一个文件将顺序地访问，那么理想情况下我们应该使文件的所有块储存在连续的相邻柱面上。<br>一个数据库被映射到多个不同的文件，一个<strong>文件（file）</strong>在逻辑上组织成为<strong>记录（record）</strong>的一个<strong>序列（sequence）</strong>。这些记录映射到<strong>磁盘块（fields）</strong>。<br>每个文件分为定长的储存单元，称为<strong>块</strong>，块是储存分配和数据传输的基本单元。<br>我们需要要求每条记录包含在单个块中，换句话说，没有记录是部分包含在一个块中，部分包含在另一个块中。这个限制简化并加速数据项访问。<br>在关系数据库中，不同关系的远组通常具有不同的大小。把数据库映射到文件的一种方法是使用多个文件，在任意一个文件中只储存一个固定长度的记录。另一种选择是构建自己的文件，使之能够容纳多钟长度的记录。定长记录比变长记录文件更容易实现。</p>
<ul>
<li><strong>定长记录（fixed-length records）</strong><br>存在的问题：</li>
</ul>
<ol>
<li>除非块的大小恰好是记录的倍数，否则部分记录会跨过快的边界，即一条记录的一部分储存在一个块里，另一部分储存在另一个块里，于是读写这样的一条记录需要两次块访问。<em>分配尽可能多的记录在一个块里</em></li>
<li>从这个结构中删除一条记录十分困难。删除的记录所占据的空间必须由文件中的其他记录来填充，或者我们必须用一种方法标记删除的记录使得它可以被忽略。*移动记录以删除记录所释放空间的做法并不理想，因为这样做需要额外的块访问操作。<br>解决方案：</li>
<li>在文件的开始处，我们分配一定数量的字节作为<strong>文件头（file header</strong>。文件头将包含有关文件的各种信息。到目前为止，我们需要在文件头中储存的只有内容被删除的第一个记录的地址。我们用这第一个记录来储存第二个可用记录的地址。我们可以直观的把这些储存的地址看作指针，因为他们指向一个记录的位置。</li>
<li>被删除的记录形成了一条<strong>链表</strong>，经常称为<strong>空闲链表（free list）</strong></li>
<li>在插入一条新记录时，我们使用文件头所指向的记录，并改变文件头的指针以指向下一个可用记录。如果没有可用的空间，我们就把这条新纪录添加到文件末尾🔚。<br><em>对于定长记录文件的插入和删除是容易实现的，因为被删除的记录留出的可用空间恰好是插入记录所需要的空间。如果我们允许文件中包含不同长度的记录，这样的匹配将不再成立。插入的记录可能无法放入一条被删除记录所释放的空间中，或者只能占用这个空间的一部分。</em></li>
</ol>
<ul>
<li><strong>变长记录（variable-length records）</strong><br>一条有变长度属性的记录表示通常具有两个部分：初识部分是定长属性，接下来是变长属性。<br>定长属性，如数字值、日期或定长字符串，分配储存它们的值所需的字节数。<br>变长属性，在记录的初始部分中表示为一个对（偏移量，长度）值，其中偏移量表示在记录中该属性的数据开始的位置，长度表示变长属性的字节长度。在记录的初识定长部分之后，这些属性的值是连续储存的。<br><em>因此，无论是定长还是变长，记录初始部分储存有关每个属性的固定长度的信息。</em></li>
</ul>
<p>一般用<strong>分槽的页结构（slotted-page structure）</strong>在块中组织记录，来处理在块中储存变长记录的问题。<br><img src="/images/7/7a3.png" alt="分槽的页结构"><br>每个块的开始有一个块头，其中包含以下信息：</p>
<ol>
<li>块头中记录条目的个数</li>
<li>块中空闲空间的末尾处</li>
<li>一个由包含记录位置和大小的记录条目组成的数组</li>
</ol>
<p>实际记录从块的<strong>尾部</strong>开始<em>连续</em>排列。块中空闲空间是连续的，在块头数组的最后一个条目和第一条记录之间。<br>如果插入一条记录，在空闲空间的尾部给这条记录分配空间，并且将包含这条记录大小和位置的条目添加到块头中。<br>如果一条记录被删除，它所占用的空间被释放，并且它的条目被设置成被删除状态（例如这条记录的大小被设置成-1）。此外，块中在被删除记录之前的记录将被移动，使得由删除而产生的空闲空间被重用，并且所有的空闲空间仍然存在于块头数组的最后一个条目和第一条记录之间。块头中的空闲空间末尾指针也要做适当修改。只要块中有空间，使用类似的技术可以使记录增长或缩短。<br><em>大对象常常被B+树文件组织</em>。</p>
<h2 id="文件中记录的组织"><a href="#文件中记录的组织" class="headerlink" title="文件中记录的组织"></a>文件中记录的组织</h2><ul>
<li><strong>堆文件组织（heap file organization）</strong>。一条记录可以放在文件中的任何地方，只要那个地方有空间存放这条记录。记录是没有顺序的。通常每个关系使用一个单独的文件。</li>
<li><strong>顺序文件组织（sequential file organization）</strong>。记录根据其“搜索码”的值顺序储存。</li>
<li><strong>散列文件组织（hashing file organization）</strong>。在每条记录的每个属性上计算一个散列函数。散列函数的结果确定了记录该放到文件的哪个块中。<br>通常，每个关系的记录用一个单独的文件储存。但是在<strong>多表聚簇文件组织（multitable clustering file organization）</strong>中，几个不同关系的记录储存在同一个文件中。而且，不同关系的相关记录储存在相同的块中，于是一个I/O操作可以从所有关系中取到相关的记录。</li>
</ul>
<p>各种方式的优劣<br><img src="/images/7/7a4.png" alt="各种文件组织的优劣"></p>
<h3 id="顺序文件组织"><a href="#顺序文件组织" class="headerlink" title="顺序文件组织"></a>顺序文件组织</h3><p><strong>顺序文件（sequential file）</strong>是为了高效处理按某个搜索码的顺序排序的记录而设计的。为了快速地按照搜索码的顺序获取记录，我们通过指针把记录链接起来，每条记录的指针指向按搜索码顺序排列的下一条记录。此外，为了减少顺序文件处理中的快访问数，我们物理上按搜索码顺序或者尽可能地接近按搜索码顺序储存记录。<br>顺序文件组织形式适合于记录按排序的顺序读取，但在插入和删除记录时维护记录的物理顺序是十分困难的。<br>我们使用指针链表来管理删除。<br>插入操作则应用以下规则：</p>
<ul>
<li>如果这条记录所在块中有一条空闲记录（删除后留下来的空间），就插到这里。</li>
<li>如果没有空闲空间，则新纪录要插入到一个<strong>溢出块（overflow block）</strong>中。<br><em>无论哪种情况，都要调整指针，使其能按搜索顺序把记录连接在一起。</em></li>
</ul>
<h3 id="多表聚簇文件组织"><a href="#多表聚簇文件组织" class="headerlink" title="多表聚簇文件组织"></a>多表聚簇文件组织</h3><p><img src="/images/7/7a5.png" alt="多表聚簇文件组织"><br>多表聚簇文件组织是一种在每一块中储存两个或更多关系的相关记录的文件结构。<br>这样的文件组织允许我们使用一次块的读操作来<strong>满足</strong>连接条件的记录。<br>但对于普通单表关系查询则会变慢<br>产生变化长度的记录<br>可以添加指针去用一种特殊的关系连接记录</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/02/CSE205W1_Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/02/CSE205W1_Introduction/" class="post-title-link" itemprop="url">CSE205W1_Introduction to the Internet</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-09-02 09:59:43" itemprop="dateCreated datePublished" datetime="2019-09-02T09:59:43+08:00">2019-09-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-15 15:07:34" itemprop="dateModified" datetime="2019-09-15T15:07:34+08:00">2019-09-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/XJTLU-Courses/" itemprop="url" rel="index"><span itemprop="name">XJTLU_Courses</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h2><p>在电路交换网络中，沿着端系统通信路径，为端系统之间通信所提供的资源（缓存、链路传输速率）在通信会话期间会被预留。<br>在分组交换网络中，这些资源则不会被预留，会话的报文按需使用这些资源，这将导致可能不得不等待（即排队）接入通信线路。<br>并非所有的电信网络都能够被明确地归类为电路交换网络或分组交换网络。</p>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="/images/6a1.png" alt="由4台交换机和4条链路组成的简单电路交换网络"><br>在上图中，每台主机（例如PC和工作站）都与一台交换机直接相连。当两台主机要通信时，该网络在两台主机之间创建一条专用的端到端连接（end-to-end connection）。因此，主机A为了向主机B发送报文，该网络必须在两条链路之一上先预留一条电路。假设每条链路具有n条电路，每条链路由端到端连接使用，该连接在连接期间获得该链路带宽的1/n部分。</p>
<h3 id="电路交换网络中的多路复用"><a href="#电路交换网络中的多路复用" class="headerlink" title="电路交换网络中的多路复用"></a>电路交换网络中的多路复用</h3><ul>
<li>链路中的电路可通过频分多路复用(Frequency-Division Multiplexing, FDM)实现。<br>对于FDM，链路的频谱由跨越链路创建的所有连接所共享。特别是，该链路在连接期间为每条连接专用一个频段。在电话网络中，这个频段通常具有4kHz（即每秒4000赫兹或4000周）。该频段的宽度被称为带宽(bandwidth)。</li>
<li>也可通过时分多路复用(Time-Division Multiplexing, TDM)实现。对于一条TDM链路，时间被划分为固定区间的帧，并且每帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，该网络在每个帧中为该连接指定一个时隙，在每个帧中具有4个时隙。一条电路的传输速率等于一个时隙中的比特数乘以该帧的速率。例如，如果链路每秒传输8000个帧，每个帧由8个比特组成，则一条电路的传输速率是64kbps。<br><img src="/images/6a2.png" alt="FDM和TDM"></li>
</ul>
<p>TDM相较于FDM优点为，当FDM中有频段未被使用时，会相应影响传输的速率。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>各种应用程序在完成其任务时要交换<strong>报文</strong>(message)。报文能够包含协议设计者需要的任何东西。<br>报文可以执行一种控制功能（握手例子中的“你好”报文，或能够包含数据（电子邮件数据、JPEG图像或MP3音频文件）。<br>在现代计算机网络中，源主机将长报文划分为较小的数据块，并称之为<strong>分组</strong>(packet)。在源和目的地之间，这些分组中的每个都通过通信链路和分组交换机(packet switch)传送。<em>交换机主要有两类：路由器和链路层交换机</em>。分组以该链路的最大传输速率在通信链路上传输。<br>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>(store-and-forward transmission)机制：在交换机能够开始向输出链路传输该分组的一个比特之前，必须接收到整个分组。</p>
<h3 id="分组交换与电路交换对比：统计多路复用"><a href="#分组交换与电路交换对比：统计多路复用" class="headerlink" title="分组交换与电路交换对比：统计多路复用"></a>分组交换与电路交换对比：统计多路复用</h3><p>分组交换总是具有与电路交换相同的性能，<em>并且用户数量是所支持的数量的3倍多也是如此</em>。<br>电路交换不考虑要求而预先分配传输链路的使用，这使得已分配但不需要的链路时间未被利用。另一方面，分组交换使用按需的方式分配链路。链路的传输能力将只在所有的其分组要在链路上传输的用户中，逐组地被共享。这样的按需共享资源有时被称为资源的<strong>统计多路复用</strong>(statistical multiplexing)。</p>
<h2 id="ISP和因特网主干"><a href="#ISP和因特网主干" class="headerlink" title="ISP和因特网主干"></a>ISP和因特网主干</h2><p>在公共因特网中，坐落在因特网边缘的接入网络通过分层的ISP层次结构与因特网的其他部分相连  </p>
<h2 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h2><h3 id="分组交换网中的时延概述"><a href="#分组交换网中的时延概述" class="headerlink" title="分组交换网中的时延概述"></a>分组交换网中的时延概述</h3><p>时延的类型</p>
<ol>
<li>节点处理时延(nodal processing delay)<br>检查分组首部和决定将该分组导向何处所需要的时间是<strong>处理时延</strong>的一部分，处理时延也包括其他因素。在这种节点处理之后，路由器将该分组引向通往路由器B之前的队列。</li>
<li>排队时延(queuing delay)<br>在队列中，当分组在链路上等待传输时，它经受<strong>排队时延</strong>。<br>一个特定分组的排队时延将取决于先期到达的、正在排队等待向链路传输的分组的数量。如果该队列是空的，并且当前没有其他分组在传输，则该分组的排队时延是0。另一方面，如果流量很大，并且许多其他分组也在等待传输，该排队时延将很大。</li>
<li>传输时延(transmission delay)<br>假定分组以先到先服务方式传输，仅当所有已经到达的分组被传输后，才能传输我们的分组。<br>用$L$比特表示分组的长度，用$R$bps表示从路由器A到路由器B的链路传输速率传输时延（又称为储存转发时延）是$L/R$。<br>假定两台主机中间有$Q$条链路，它必须储存转发$Q$次，因此总时延为$QL/R$。</li>
<li>传播时延(proagation delay)<br>一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间是<strong>传播时延</strong>，该传播速率取决于该链路的物理媒体（即光纤、双绞铜线等）。<br>如果$d$是路由器A和路由器B之间的距离，$s$是传播速率，传播时延等于两台路由器之间的距离除以传播速率，即传播时延是$d/s$。<br>若传输时延大于传播时延，则会出现一个分组中的前几个比特到达了一台路由器，而该分组中还有余下的比特仍在前面的路由器中等待传输。</li>
</ol>
<p>如果令<script type="math/tex">d_{proc}，d_{queue}，d_{trans}，d_{prop}</script>分别表示处理时延、排队时延、传输试验和传播时延，则节点的总延时由下式给定：</p>
<script type="math/tex; mode=display">
d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}</script><h3 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h3><p>与其他三项时延不同的是，排队时延对不同的分组是不同的。例如，如果10个分组同时到达空队列，传输的第一个分组没有排队时延，而传输的最后一个分组将经受相对大的排队时延（这时它要等待其他九个分组被传输）。<br>$a$表示分组到达队列的平均速率（$a$的单位是每秒分组，即pkt/s），$R$是传输速率，即比特从队列中推出的速率（以bps为单位），假定所有分组都是由$L$比特组成的，则比特到达队列的平均速率是$La$bps。最后，假定该队列非常大，因此它基本能容纳无限数量的比特，比率$La/R$被称为<strong>流量强度(traffic intensity)</strong>。</p>
<ol>
<li>如果$La/R &gt; 1$，则比特到达队列的平均速率超过从该队列传输出去的速率。在这种情况下，队列的增加将趋于无界，并且排队时延将趋于无限大，因此，<strong>设计系统时流量强度不能大于1</strong></li>
<li>考虑$La/R &lt;= 1$时</li>
</ol>
<ul>
<li>如果分组周期性到达，每个分组将到达一个空队列中，因此不会有排队时延。</li>
<li>如果分组以突发形式到达而不是周期性到达，则有可能有很大的平均排队时延。<br><img src="/images/6a3.png" alt="平均排队时延和流量强度的关系"></li>
</ul>
<h3 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h3><p>排在一条链路前的队列只有有限的容量，所以流量强度接近于1时排队时延也不会趋向于无穷大，相反，到达的分组将会发现一个满的队列。由于没有地方存储这个分组，路由器将<strong>丢弃(drop)</strong>该分组，即该分组将会<strong>丢失(lost)</strong>。<br>节点的性能常常不仅要根据时延来度量，而且要根据分组丢失的概率来度量。</p>
<h3 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h3><p>为了定义吞吐量，考虑从主机A到主机B通过计算机网络传送一个大文件。</p>
<ul>
<li>瞬时吞吐量(instantaneous throughput)是主机B接收到该文件的速率（以bps计）。</li>
<li>平均吞吐量(average throughput)：若主机B接收到所有$F$比特用了$T$秒，则文件传送的<strong>平均吞吐量</strong>是$f/t$bps。<br>考虑计算机网络中的几个关于吞吐量的例子：<br><img src="/images/6a4.png" alt="从服务器传送一个文件到客户机的吞吐量"></li>
</ul>
<ol>
<li><p>令$R_s$表示服务器与路由器之间的链路速率；$R_c$表示路由器与客户机之间的链路速率。对于这种简单的两链路网络，其吞吐量是<strong>min{$R_c,R_s$}</strong>，也就是说是<strong>瓶颈链路(bottleneck link)</strong>的传输速率。在确定了吞吐量后，我们现在近似地得到从服务器到客户机传输一个$F$比特的大文件所需要的时间是$F$/min{$R_c,R_s$}。得到的表达式是近似的是因为没有考虑分组层次和协议的问题。</p>
</li>
<li><p>服务器以接入速率$R_s$与网络相连，客户机以接入速率$R_c$与网络相连，现在假定计算机网络核心中的所有链路具有非常高的传输速率，远远超过$R_s$和$R_c$。在这个例子中，因为计算机网络的核心就像一个宽大的管子。所以比特从源向目的地流动速率还是$R_s$和$R_c$中的较小者，即min{$R_s,R_c$}。目前，因特网中对吞吐量的限制因素通常是接入网。<br><img src="/images/6a5.png" alt="10个客户机从10个服务器下载文件"></p>
</li>
<li>若有10个服务器和10个客户机与计算机网络核心相连。假设这条链路的传输速率为$R$，再假定所有服务器接入链路的速率都是$R_s$，所有客户机接入链路的速率都是$R_c$。</li>
</ol>
<ul>
<li>如果公共链路的速率$R$很大，比$R_s$和$R_c$大100倍，则每个下载的吞吐量仍是min{$R_s,R_c$}。因为公共链路对10个下载平分其传输速率，假设平分完后的速率小于$R_s$和$R_c$，则吞吐量取决于平分后公共链路传输速率。</li>
</ul>
<h2 id="协议层次和他们的服务模型"><a href="#协议层次和他们的服务模型" class="headerlink" title="协议层次和他们的服务模型"></a>协议层次和他们的服务模型</h2><h3 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h3><p>利用分层的体系结构，我们可以讨论一个定义良好的、大而复杂的系统的特定部分。这种简化本身由于提供模块化而具有很高的价值，这使得由层所提供的服务的实现易于改变。<br>只要该层对其上面的层提供相同的服务，并且使用来自下面层次的相同服务，当某层的实现变化时，该系统的其余部分就可以保持不变。<br>对于大而复杂且需要不断更新的系统，改变服务的实现而不影响该系统其他部分的能力是分层的另一个重要优点。</p>
<h4 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h4><p>为了给网络协议的设计者提供一个结构，网络设计者以<strong>分层(layer)</strong>的方式组织协议及实现这些协议的网络硬件和软件。每层通过在该层中执行某些动作，或直接下层的服务，来提供他的服务。<br>各层的所有协议综合起来被称为协议栈(protocol stack)。因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。</p>
<ol>
<li>应用层<br>应用层是网络应用程序及其应用层协议存留的地方。<br>应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们将这种位于应用层的信息称为<strong>报文(message)</strong>。</li>
<li>运输层<br>运输层提供了在应用程序端点之间传送应用层报文的服务。<br>TCP向他的应用程序提供了面向连接的服务。这种服务包括了应用层报文向目的地确保传输和流量控制。TCP也将长报文划分为短报文，并提供拥塞机制，因此当网络拥塞时，源抑制其传输速率。<br>UPD协议香它的应用程序提供无连接服务。<br>在本书中，我们将运输层称为<strong>报文段(segment)</strong></li>
<li>网络层<br>因特网的网络层负责将称为<strong>数据报(datagram)</strong>的网络层分组从一台主机移动到另一台主机。</li>
<li>链路层<br>为了将分组从一个节点（主机或路由器）移动到数据上的下一个节点，网络层必须依靠链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给 下一个节点。在该下个节点，链路层将数据报上传给网络层。<br>链路层提供的服务取决于应用于该链路的特定链路层协议。<br>链路层分组被称为<strong>帧(frame)</strong>。</li>
<li>物理层<br>物理层的任务是将该帧中的一个一个比特从一个节点移动到下一个节点。该层中的协议仍是链路相关的，并且进一步与链路（例如，双铜绞线、单模光纤）的实际运输媒体相关。</li>
<li>ISO模型<br>因特网协议栈并不是唯一的协议栈，国际标准化组织（ISO）提出计算机网络应组织为大约七层，称为开放系统互连（OSI）。OST参考模型的七层是：应用层、表示层、会话层、运输层、网络层、链路层和物理层。<br>表示层的作用是使通信的应用程序能够解释交换数据的含义，它所提供的服务包括数据压缩、数据加密以及数据描述。<br>会话层提供了数据交换的定界和同步功能，包括建立检查点和恢复方案的方法。</li>
</ol>
<h3 id="报文、报文段、数据报和帧"><a href="#报文、报文段、数据报和帧" class="headerlink" title="报文、报文段、数据报和帧"></a>报文、报文段、数据报和帧</h3><p><img src="/images/6a6.png" alt="主机、路由器和链路层交换机，每个包含了不同的层，反映了不同的功能"><br>在发送主机，<strong>应用层报文(application-layer message)</strong>(图中的M)被传送给运输层。<br>在最简单的情况下，运输层收取报文并附上附加信息（即运输层首部信息，图中的$H_t$），该首部将被接收端的运输层使用。应用层报文和运输层首部信息共同构成了<strong>运输层报文段(transport-layer segment)</strong>。运输层报文段因此封装了应用层报文，<br>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息（图中的$H_n$），形成了<strong>网络层数据报(network-layer datagram)</strong>。<br>该数据报接下来被传递给链路层，链路层当然也增加它自己的链路层首部信息并创建了<strong>链路层帧(link-layer frame)</strong>。<br><em>在每一层，分组具有两种类型的字段：首部字段和<strong>有效荷载字段(payload field)</strong>。有效荷载通常来则上一级的分组。这也说明了<strong>封装(encapsulation)</strong>这一重要概念</em>。</p>
<h2 id="攻击威胁下的网络"><a href="#攻击威胁下的网络" class="headerlink" title="攻击威胁下的网络"></a>攻击威胁下的网络</h2><ol>
<li>坏家伙能够经因特网将恶意软件放入你的计算机<br>设备与因特网相连，接受或发送的数据中包含好的东西和不好的东西，这些不好的东西统称为<strong>恶意软件(malware)</strong>，他能够影响我们的设备。<br>受害主机还可能征召网络上数以千计的类似受害设备，它们被统称为<strong>僵尸网络(botnet)</strong>。<br>大多数恶意软件是<strong>自我复制(self-replicating)</strong>的：一旦它感染了一部主机，就会从那台主机进入更多的主机。</li>
</ol>
<ul>
<li><strong>病毒(virus)</strong>是一种需要某种形式的用户交互来感染用户设备的恶意软件。</li>
<li><strong>蠕虫(worm)</strong>是一种无需任何明显用户交互就能进入设备的恶意软件。</li>
</ul>
<ol>
<li><p>坏家伙能够攻击服务器和网络基础设施<br><strong>拒绝服务(Denial-of-Service,DoS)攻击</strong>是一种宽泛类型的安全性威胁。DoS攻击使得合法用户不能使用网络、主机或其他基础设施部分。<br>大多数因特网DoS攻击属于下列三种：<em>弱点攻击、带宽洪泛、连接洪泛</em>。<br>攻击者还可使用僵尸网络产生<strong>分布式DoS(distributed DoS,DDoS)</strong>去攻击。</p>
</li>
<li><p>坏家伙能够嗅探分组<br><strong>分组嗅探器(packet sniffer)</strong></p>
</li>
<li><p>坏家伙能够伪装层你信任的人<br>一个不可信的接收方（比如说因特网上的一台路由器）接受了分组，用（虚假的）源地址伪装真实的源地址，进而执行某些嵌入在该分组中的命令（比如说修改它的转发表），将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗(IP spoofing)</strong>，它只是一个用户能够冒充另一个用户的多种方式之一。</p>
</li>
<li><p>坏家伙能够修改或删除报文</p>
</li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/31/Java_Initialization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/31/Java_Initialization/" class="post-title-link" itemprop="url">Java Initialization</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-31 17:29:20" itemprop="dateCreated datePublished" datetime="2019-08-31T17:29:20+08:00">2019-08-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-09-01 22:41:07" itemprop="dateModified" datetime="2019-09-01T22:41:07+08:00">2019-09-01</time>
              </span>
            
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>概念： 在创建对象时被自动调用的特殊方法，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能将它自动释放。<br>不接受任何参数的构造器叫做默认构造器，Java文档中通常使用术语无参构造器。但是和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。如果Tree(int)是Tree类中唯一的构造器，那么编译器将不会允许你以其他任何方法创建Tree对象。在Java中，“初始化”和“创建”捆绑在一起，两者不能分离。构造器本身并没有任何返回值。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>任何程序设计语言都具备的一项重要特性就是对名字的运用。当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。在Java里，构造器是强制重载方法名的另一个原因。既然构造器的名字已经由类名决定，就只能有一个构造器名。为了让方法名相同而形式参数不同的构造器同时存在，必须要用到方法重载。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.midview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    Tree()&#123;</span><br><span class="line">        print(<span class="string">"Planting a seedling"</span>);</span><br><span class="line">        height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree(<span class="keyword">int</span> initialHeight)&#123;</span><br><span class="line">        height = initialHeight:</span><br><span class="line">        print(<span class="string">"Creating new Tree that is "</span> + height + <span class="string">" feet tall"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(<span class="string">"Tree is "</span> + height + <span class="string">"feet tall"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        print(s + <span class="string">": Tree is "</span> + height + <span class="string">" feet tall"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>有了方法重载，可以为两者使用相同的名字</em></p>
<h3 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h3><p>重载的方法通过独一无二的<strong>参数类型列表</strong>去让Java便于区分，甚至<strong>参数顺序</strong>不同也足以区分两个方法。<em>不过一般情况下别这么做，因为这会使代码难以维护</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingOrder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, String s)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h3><p><strong>byte8位，short16位，int32位，long64位，float单精度32位，double双精度64位，char单一的16位Unicode字符</strong><br>基本类型能从一个“较小”的类型自动提升至一个“较大”的类型。如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。<strong>char</strong>型略有不同，如果无法找到恰好接受<strong>char</strong>参数的方法，就会把<strong>char</strong>直接提升至<strong>int</strong>型。<br>如果传入的实际参数较大，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。</p>
<h3 id="以返回值区分重载方法"><a href="#以返回值区分重载方法" class="headerlink" title="以返回值区分重载方法"></a>以返回值区分重载方法</h3><p>根据方法的返回值来区分重载方法是行不通的。</p>
<h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。<br>如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird2</span></span>&#123;</span><br><span class="line">    Bird2(<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">    Bird2(<span class="keyword">double</span> d)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSynthesis</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//! Bird2 b = new Bird2(); //No default</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果按照上述编写会报错。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peeler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Apple <span class="title">peel</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="function">Apple <span class="title">getPeeled</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Peeler.peel(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了将自身传递给外部方法，<strong>Apple</strong>必须使用<strong>this</strong>关键字。<br>可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可用<strong>this</strong>关键字做到这一点。<br>```java<br>public class Flower{<br>    int petalCount = 0;<br>    String s = “initial value”;<br>    Flower(int petals){}<br>    Flower(String ss){}<br>    Flower(String s, int petals){<br>        this(petals);<br>        //! this(s); //Can’t call two!<br>        this.s = s<br>    }<br>}</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/Java_Array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/27/Java_Array/" class="post-title-link" itemprop="url">Java 数组</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-27 20:13:37 / Modified: 21:13:30" itemprop="dateCreated datePublished" datetime="2019-08-27T20:13:37+08:00">2019-08-27</time>
            </span>
          
            

            
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数组与其他种类容器之间的区别有三方面：效率、类型和保存基本类型的能力。<br>在Java中，数组是一种效率最高的储存和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但这种速度所付出的代价是数组对象的大小被固定。ArrayList的效率比数组低很多。这两种持有对象的方式都是类型检查型的，并且唯一明显的差异就是数组使用[]来访问元素。而List使用的是add()和get()这样的方法。<br>length是数组的大小，而不是实际保存的元素个数，所以检查其中的引用是否为null，即可知道数组的某个位置是否存有对象。同样，基本类型的数组如果是数值型的，就被自动初始化为0，如果是字符型（char）的，就被自动初始化为（char）O；如果是布尔型（boolean），就被自动初始化为false。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>创建多维数组很方便。对于基本类型的多维数组，可以通过使用花括号将每个向量分隔开，每对花括号括起来的集合都会把你带到下一级数组。Java SE5的Arrays.deepToString()方法，它可以将多维数组转换为多个String。数组中构成矩阵的每个向量都可以具有任意的长度（这被称为粗糙数组）。<br>编写一个方法能够产生二维双精度型数组并加以初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[][][] creation(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">		Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">		<span class="keyword">int</span> c = b - a;</span><br><span class="line">		<span class="keyword">double</span> d[][][]  = <span class="keyword">new</span> <span class="keyword">double</span>[rand.nextInt(c) + a] [][];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.length; i++) &#123;</span><br><span class="line">			d[i] = <span class="keyword">new</span> <span class="keyword">double</span>[rand.nextInt(c) + a][];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d[i].length; j++) &#123;</span><br><span class="line">				d[i][j] = <span class="keyword">new</span> <span class="keyword">double</span>[rand.nextInt(c) + a];</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; d[i][j].length; q++) &#123;</span><br><span class="line">					d[i][j][q] = rand.nextDouble();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> d;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Arrays实用功能"><a href="#Arrays实用功能" class="headerlink" title="Arrays实用功能"></a>Arrays实用功能</h2><ul>
<li><p>Arrays.fill() <em>只能用同一个值填充各个位置</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">Arrays.fill(a,<span class="number">19</span>);</span><br><span class="line">print(<span class="string">"a = "</span> + Arrays.toString(a));</span><br></pre></td></tr></table></figure>
</li>
<li><p>System.arraycopy() <em>不属于Arrays但是很有用的方法</em> <em>static</em><br>它用来复制数组比用for循环复制要快很多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span>[] j = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(i, <span class="number">47</span>);</span><br><span class="line">Arrays.fill(j, <span class="number">99</span>);</span><br><span class="line">System.arraycopy(i, <span class="number">0</span>, j, <span class="number">0</span>, i.length)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>arraycopy()需要的参数有：源数组，表示从源数组中的什么位置开始复制的偏移量，表示从目标数组的什么位置开始的偏移量，以及需要复制的元素个数。<em>对数组的任何越界操作都会导致异常</em><br><em>System.arraycopy()不会执行自动包装和自动拆包，两个数组必须具有相同的确切类型。</em></p>
<ul>
<li><p>equals()<br>Arrays类提供了重载后的equals()方法，用来比较整个数组<br>数组相等的条件是元素个数必须相等，并且对应位置的元素也相等，这可以通过对每一个元素使用equals()作比较来判断。（*对基本类型，需要使用基本类型的包装器类的equals()方法<br>deepEquals()用于多维数组</p>
</li>
<li><p>sort()用于对数组排序</p>
</li>
<li><p>binarySearch()用于在已经排列的数组中查找元素</p>
</li>
<li><p>toString()产生数组的String表示</p>
</li>
<li><p>hashCode()产生数组的散列码</p>
</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/22/CNN_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/22/CNN_1/" class="post-title-link" itemprop="url">初识CNN</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-22 22:05:10" itemprop="dateCreated datePublished" datetime="2019-08-22T22:05:10+08:00">2019-08-22</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-27 20:11:52" itemprop="dateModified" datetime="2019-08-27T20:11:52+08:00">2019-08-27</time>
              </span>
            
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="Convolutional-Neural-Networks-CNNs"><a href="#Convolutional-Neural-Networks-CNNs" class="headerlink" title="Convolutional Neural Networks(CNNs)"></a>Convolutional Neural Networks(CNNs)</h2><h3 id="CNNs的结构"><a href="#CNNs的结构" class="headerlink" title="CNNs的结构"></a>CNNs的结构</h3><p><img src="/images/3a1.png" alt="&quot;Figure 1: Convolutional Neural Network for Relation Extraction&quot;"></p>
<h4 id="Convolution-卷积"><a href="#Convolution-卷积" class="headerlink" title="Convolution (卷积)"></a>Convolution (卷积)</h4><h5 id="卷积的数学理解"><a href="#卷积的数学理解" class="headerlink" title="卷积的数学理解"></a>卷积的数学理解</h5><h6 id="1、卷积的定义"><a href="#1、卷积的定义" class="headerlink" title="1、卷积的定义"></a>1、卷积的定义</h6><p>我们称 $(f*g)(n)$ 为 $f,g$ 的卷积<br>其连续的定义为：</p>
<script type="math/tex; mode=display">
(f*g)(n) = \int_{-\infty}^{+\infty} {f(t)g(n - t)}  {\rm d}t</script><p>其离散的定义为：</p>
<script type="math/tex; mode=display">
(f*g)(n) = \sum_{t=-\infty}^{\infty} {f(t)g(n - t)}</script><p>这两个式子有一个共同特征：都类似于$n = t + n - t$<br>我们令$x = r, y = n - r$,那么$x + y = n$ 就是下面这些直线<br><img src="/images/3a2.gif" alt="lines"></p>
<h6 id="2、离散卷积的例子：丢骰子"><a href="#2、离散卷积的例子：丢骰子" class="headerlink" title="2、离散卷积的例子：丢骰子"></a>2、离散卷积的例子：丢骰子</h6><p>将两枚🎲抛出去，两枚🎲点数加起来为4的概率是多少？<br>我们把🎲各个点数出现的概率表示出来：<br>相加点数4出现概率为：$f(1)g(3)$ $f(2)g(2)$ $f(3)g(1)$<br>因此，两枚🎲点数加起来为4的概率为：$f(1)g(3) + f(2)g(2) + f(3)g(1)$<br>符合卷积的定义，把它写成标准的形式就是：</p>
<script type="math/tex; mode=display">
(f*g)(4) = \sum_{m=1}^{3} {f(4 -m)g(m)}</script><h6 id="3、连续卷积的例子：做馒头"><a href="#3、连续卷积的例子：做馒头" class="headerlink" title="3、连续卷积的例子：做馒头"></a>3、连续卷积的例子：做馒头</h6><p>假设我们拥有一台可以一天不断生产馒头的机器<br>假设馒头的生产速度为$f(t)$，那么一天后生产出的馒头总量为：</p>
<script type="math/tex; mode=display">
\int_0^{24} {f(t)} {\rm d}t</script><p>馒头生产出来后会慢慢腐败，假设腐败函数为$g(t)$，比如，10个馒头，24小时会腐败 $10*g(t)$<br>如此，我们可以知道，一天后，馒头总共腐败了：</p>
<script type="math/tex; mode=display">
\int_0^{24} {f(t)g(24-t)} {\rm d}t</script><h5 id="卷积的实际运用"><a href="#卷积的实际运用" class="headerlink" title="卷积的实际运用"></a>卷积的实际运用</h5><p>基础CNN所用的卷积是一种2D卷积。Kernel只能在x,y上滑动位移，不能进行深度（跨通道）位移。<br>对于RGB图像，采用了三个独立的2D kernel，如黄色部分，这个kernel的维度是$X*Y*3$。再基础CNN的不同stage中，kernel的深度都应当一致，等于输入图像的通道数。<br>卷积需要输入两个参数，实质是二维空间滤波，滤波的性质与kernel选择有关，CNN的卷积是在一个2-D kernel 和输入的 2-D input map 之间，RGB中各图像通道分别完成。<br>我们假设单一通道输入图像的空间坐标为$(x,y)$ ，卷积核大小是$p * q$ ，kernel权重为$w$ ,图像亮度值是$v$ ，卷积过程就是kernel 所有权重与其在输入图像上对应元素亮度之和，可以表示为：</p>
<script type="math/tex; mode=display">
conv_{x,y} = \sum_i^{p*q} {w_i}{v_i}</script><p><img src="/images/3a3.jpeg" alt="convolution"><br>并将kernel随（x,y）平移扫描，可以得到输出空间，这时假设输入图像大小是$512*512$，卷积核是$3*3$，在不考虑零填充（zero padding）的情况，输出是（512 - 3 + 1） = 510 *510<br>卷积层的kernel可能不止一个，扫描步长，方向也有不同，这些进阶方式可以归纳一下：</p>
<ul>
<li>可以采用多个卷积核，设为n同时扫描，得到的feature map会增加n个维度，通常认为是多抓取n个特征</li>
<li>可以采取不同扫描步长，比如上例子中采用步长为n，输出是（510/n，510/n）</li>
<li>padding，上例中，卷积过后的图像维度是缩减的，可以在图像周围填充0来保证feature map与原始图像大小不变</li>
<li>深度升降，例如采用增加一个1*1 kernel来增加深度，相当于复制一层前通道作为feature map</li>
<li>跨层传递feature map，不再局限于输入即输出，例如ResNet跨层传递特征，Faster RCNN 的POI pooling</li>
</ul>
<h4 id="Activation（激活）"><a href="#Activation（激活）" class="headerlink" title="Activation（激活）"></a>Activation（激活）</h4><p>卷积之后，通常会加入偏置(bias), 并引入非线性激活函数(activation function)，这里定义bias为b，activation function 是h（），经过激活函数后，得到的结果是,</p>
<script type="math/tex; mode=display">
Z_{x,y} = h(\sum_i^{p*q} {w_i}{v_i} + b)</script><p><em>bias不与元素位置相关，只与层有关</em><br>主流的activation function 有：<br><img src="/images/3a4.png" alt="activation functions"><br>例如采用$277*277$的RGB图像， 采用96个$11*11*3$的kernels同时扫描，很容易得到输出的feature maps是96个$267*267$的二维 feature map, $267*267$是单个图像feature map的x,y轴大小，96是卷积核个数，原本的3通道在积分的时候会被作为一个元素加起来。 如上图，这些feature map可视化之后，可以看到4和35表示边缘特征，23是模糊化的输入，10和16在强调灰度变化，39强调眼睛，45强调红色通道的表现。</p>
<h4 id="Pooling-池化"><a href="#Pooling-池化" class="headerlink" title="Pooling (池化)"></a>Pooling (池化)</h4><p>池化(pooling），是一种降采样操作(subsampling)，主要目标是降低feature maps的特征空间，或者可以认为是降低feature maps的分辨率。因为feature map参数太多，而图像细节不利于高层特征的抽取。<br><img src="/images/3a5.jpeg" alt="pooling"><br>目前主要的pooling操作有:</p>
<ul>
<li>最大值池化 Max pooling: $2*2$的max pooling就是取4个像素点中最大值保留</li>
<li>平均值池化 Average pooling, $2*2$的average pooling就是取4个像素点中平均值保留</li>
<li>L2池化 L2 pooling: 即取均方值保留<br>Pooling操作会降低参数，降低feature maps的分辨率，但是这种暴力降低在计算力足够的情况下是不是必须的，并不确定。目前一些大的CNNs网络只是偶尔使用pooling.</li>
</ul>
<p>该CNN stage的基本结构是可变的，目前大部分网络都是根据基本结构堆叠调整参数，或跳层连接而成</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/Github+Hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="2AM">
      <meta itemprop="description" content="they said the fruit never gon' fall far from the tree">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Room of Requirment">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/12/Github+Hexo/" class="post-title-link" itemprop="url">Github + Hexo (Mac)</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-12 23:59:52" itemprop="dateCreated datePublished" datetime="2019-08-12T23:59:52+08:00">2019-08-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-21 14:33:14" itemprop="dateModified" datetime="2019-08-21T14:33:14+08:00">2019-08-21</time>
              </span>
            
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="安装git配置用户名和邮箱"><a href="#安装git配置用户名和邮箱" class="headerlink" title="安装git配置用户名和邮箱"></a>安装git配置用户名和邮箱</h2><p>查看当前电脑是否安装git <code>git --version</code><br>初次安装git需要配置用户名和邮箱，否则git会提示：<em>please tell me who you are</em><br>运行命令来配置你的用户名和邮箱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;2AM-official&quot;</span><br><span class="line">$ git config --global user.email &quot;zhaoxinglyu@icloud.com&quot;</span><br></pre></td></tr></table></figure></p>
<p><em>此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱，但我在这里为了省事直接使用我本人的github邮箱</em></p>
<h2 id="git使用ssh密匙"><a href="#git使用ssh密匙" class="headerlink" title="git使用ssh密匙"></a>git使用ssh密匙</h2><p>git支持https和git两种传输协议，github分享链接时会有两种协议可选：git协议链接和https协议链接。<br><em>git使用https协议，每次pull，push都会提示要输入密码；使用git协议，然后使用ssh密匙，这样可以免去每次都输密码的麻烦</em></p>
<h3 id="初次使用git的用户要使用git协议大概需要三个步骤："><a href="#初次使用git的用户要使用git协议大概需要三个步骤：" class="headerlink" title="初次使用git的用户要使用git协议大概需要三个步骤："></a>初次使用git的用户要使用git协议大概需要三个步骤：</h3><p>1、生成密匙对<br>2、设置远程仓库（本文以github为例）上的公匙<br>3、把git的remote url修改为git协议<br><em>以上两个步骤初次设置过后，以后都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤</em></p>
<h4 id="生成密匙对"><a href="#生成密匙对" class="headerlink" title="生成密匙对"></a>生成密匙对</h4><p>大多数git服务器都会选择使用SSH公匙来进行授权。系统中的每个用户都必须提供一个公匙用于授权，没有的话就要生成一个。<br>生成公匙的过程在所有操作系统上都差不多，首先要确认一下本机是否已经有一个公匙。<br>SSH公匙默认储存在账户的主目录下<code>~/.ssh</code>目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br></pre></td></tr></table></figure></p>
<p>看一下有没有id_rsa和id_rsa.pub（或者是id_dsa和id_dsa.pub之类成对的文件），有.pub后缀的文件就是公匙，另一个文件则是密匙。<br>假如没有这些文件，甚至连.ssh目录都没有，可以用ssh-keygen来创建。该程序在Linux/Mac系统上由SSH包提供。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@yourmail.com&quot;</span><br><span class="line"></span><br><span class="line">Creates a new ssh key using the provided email #Generating public/private rsa key pair.</span><br><span class="line"></span><br><span class="line">Enter file in which to save the key (/home/you/.ssh/id_rsa):</span><br></pre></td></tr></table></figure></p>
<p>直接按Enter就行，然后会提示你输入密码，如下 <em>建议输一个，安全一点；不输也行</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure></p>
<p>完了之后，大概是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Your public key has been saved in /home/you/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com</span><br></pre></td></tr></table></figure></p>
<p>到此为止，你的本地密匙对就生成了</p>
<h4 id="2、添加公匙到你的远程仓库（github）"><a href="#2、添加公匙到你的远程仓库（github）" class="headerlink" title="2、添加公匙到你的远程仓库（github）"></a>2、添加公匙到你的远程仓库（github）</h4><p>1）查看你生成的公匙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC</span><br></pre></td></tr></table></figure></p>
<p>2）登陆你的github账户。点击你的头像，然后<strong>Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key</strong><br>3）复制上面公匙内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。<br>4）点击Add key。<br>完成以后，验证下这个key是不是正常工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">Attempts to ssh to github</span><br></pre></td></tr></table></figure></p>
<p>如果看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxx! You&apos;ve successfully authenticated, but GitHub does not # provide shell access.</span><br></pre></td></tr></table></figure></p>
<p>则为设置成功</p>
<h4 id="3、修改git的remote-url"><a href="#3、修改git的remote-url" class="headerlink" title="3、修改git的remote url"></a>3、修改git的remote url</h4><p>使用命令<code>git remote -v</code>查看你当前的remote url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin https://github.com/someaccount/someproject.git (fetch)</span><br><span class="line">origin https://github.com/someaccount/someproject.git (push)</span><br></pre></td></tr></table></figure></p>
<p><em>如果是以上的结果那么说明此项目是使用https协议进行访问的,如果地址是git开头则表示是git协议</em><br>你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url<br>复制此ssh链接，然后使用命令 git remote set-url 来调整你的url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:someaccount/someproject.git</span><br></pre></td></tr></table></figure></p>
<p>然后你可以用命令<code>git remote -v</code>查看一下，url是否已经变成了ssh地址<br>然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h3 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h3><p>因为hexo是基于nodejs的应用，所以要先安装nodejs才可以，使用以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install nodejs</span><br><span class="line">$ sudo apt-get install npm</span><br></pre></td></tr></table></figure></p>
<h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>Hexo 是一个功能强大的静态网站生成系统，快速、简洁、高效。Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。可以一键部署到github，还有丰富的插件和主题,还支持热部署哦。执行如下命令进行安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>安装Hexo成功后，使用如下命令快速新建一个博客系统，然后运行它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ cd blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<p><em>如果npm安装失败，使用sudo安装</em><br>运行成功后，访问http：//0.0.0.0：4000/ 就可以看到博客的样子</p>
<h3 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h3><p>使用如下命令新增一篇md格式的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &apos;your title&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h3><p>上面只是在本地预览，接下来做的就是推送网站，也就是发布网站。<br>在blog根目录里的_config.yml文件称为<strong>站点配置文件</strong><br>在根目录里的themes文件夹，里面也有个_config.yml文件，这个称为<strong>主题配置文件</strong><br>下一步将我们的Hexo和github关联起来，打开站点的配置文件_config.yml，翻到最后修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></p>
<p>保存站点配置文件<br>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>再分别输入三条命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p>
<p><em>其实第三条的<code>hexo d</code>就是部署网站命令，d是deploy的缩写</em><br>完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径即可</p>
<h3 id="Acknowledge"><a href="#Acknowledge" class="headerlink" title="Acknowledge:"></a>Acknowledge:</h3><p><a href="https://help.github.com/en/articles/caching-your-github-password-in-git#platform-linux" target="_blank" rel="noopener">https://help.github.com/en/articles/caching-your-github-password-in-git#platform-linux</a><br><a href="https://www.tuicool.com/articles/BzUrAvF" target="_blank" rel="noopener">https://www.tuicool.com/articles/BzUrAvF</a><br><a href="https://www.cnblogs.com/zhaoyu1995/p/6239950.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyu1995/p/6239950.html</a><br><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">2AM</p>
  <div class="site-description motion-element" itemprop="description">they said the fruit never gon' fall far from the tree</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">2AM</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>






  




























  

  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
      <script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  

  

  


  
  
</body>
</html>
